// app/api/admin/login/route.ts
import { NextRequest, NextResponse } from "next/server";
import { randomBytes, timingSafeEqual } from "crypto";
import { auditLogger } from "@/lib/audit/audit-logger";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

// ==================== TYPES ====================
interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  retryAfterMs?: number;
  resetTime: number;
  limit: number;
  windowMs: number;
  blocked?: boolean;
  blockUntil?: number;
}

interface RateLimitOptions {
  limit: number;
  windowMs: number;
  keyPrefix?: string;
  blockDuration?: number;
}

interface RateLimitRedisModule {
  rateLimitRedis?: {
    check: (key: string, opts: RateLimitOptions) => Promise<RateLimitResult>;
  };
  default?: {
    check: (key: string, opts: RateLimitOptions) => Promise<RateLimitResult>;
  };
}

interface UnifiedRateLimitModule {
  withEdgeRateLimit?: (
    req: NextRequest,
    cfg: RateLimitOptions
  ) => Promise<{ allowed: boolean; result?: RateLimitResult }>;
  RATE_LIMIT_CONFIGS?: {
    AUTH?: RateLimitOptions;
  };
  createRateLimitedResponse?: (result: RateLimitResult) => Response;
  createRateLimitHeaders?: (result: RateLimitResult) => Record<string, string>;
}

interface AdminUser {
  id: string;
  username: string;
  role: "admin" | "superadmin" | "editor";
  permissions: string[];
  mfaEnabled: boolean;
  status?: string;
  passwordHash?: string;
  failedLoginAttempts?: number;
  lastLoginAt?: Date;
}

interface AuthResult {
  success: boolean;
  user?: AdminUser;
  error?: string;
  requiresMFA?: boolean;
}

interface SessionResult {
  token: string;
  csrfToken?: string;
  userId: string;
  expiresAt?: Date;
}

interface RateLimitCheckResult {
  limited: boolean;
  result?: RateLimitResult;
}

// ==================== UTILITY FUNCTIONS ====================
async function safeImport<T = any>(specifier: string): Promise<T | null> {
  try {
    return (await import(specifier)) as unknown as T;
  } catch (error) {
    console.warn(`[SafeImport] Failed to import ${specifier}:`, error);
    return null;
  }
}

function toUint8Array(input: string): Uint8Array {
  return new TextEncoder().encode(input);
}

function timingSafeEqualBytes(a: Uint8Array, b: Uint8Array): boolean {
  if (a.length !== b.length) return false;
  return timingSafeEqual(a, b);
}

function getClientIp(req: NextRequest): string {
  const xff = req.headers.get("x-forwarded-for");
  if (xff) return xff.split(",")[0]?.trim() || "unknown";
  return req.headers.get("x-real-ip")?.trim() || "unknown";
}

function jsonError(message: string, status: number): NextResponse {
  return NextResponse.json({ error: message }, { status });
}

function normalizeUsername(v: unknown): string {
  return typeof v === "string" ? v.trim().toLowerCase() : "";
}

function normalizePassword(v: unknown): string {
  return typeof v === "string" ? v : "";
}

function normalizeRememberMe(v: unknown): boolean {
  return v === true || v === "true" || v === "1";
}

async function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// ==================== RATE LIMITING ====================
async function loadRateLimiters(): Promise<{
  rateLimitRedis: any;
  rateLimitModule: UnifiedRateLimitModule | null;
}> {
  const redisModule = await safeImport<RateLimitRedisModule>("@/lib/rate-limit-redis");
  const unifiedModule = await safeImport<UnifiedRateLimitModule>(
    "@/lib/server/rate-limit-unified"
  );

  const rateLimitRedis = redisModule?.rateLimitRedis || redisModule?.default || null;
  return { rateLimitRedis, rateLimitModule: unifiedModule };
}

async function applyRateLimiting(
  req: NextRequest,
  clientIp: string,
  rateLimitRedis: any,
  rateLimitModule: UnifiedRateLimitModule | null
): Promise<RateLimitCheckResult> {
  const rateLimitKey = `auth:${clientIp}`;
  let rateLimitResult: RateLimitResult | undefined;

  // 1. Try Redis rate limiting
  if (rateLimitRedis?.check) {
    try {
      rateLimitResult = await rateLimitRedis.check(rateLimitKey, {
        windowMs: 60_000,
        limit: 5,
        keyPrefix: "auth_login",
        blockDuration: 300_000,
      });

      if (rateLimitResult && !rateLimitResult.allowed) {
        console.warn(`[AdminLogin] Rate limited via Redis: ${clientIp}`);
        return { limited: true, result: rateLimitResult };
      }
    } catch (error) {
      console.warn("[AdminLogin] Redis rate limit error:", error);
    }
  }

  // 2. Try unified rate limiting
  if (!rateLimitResult && rateLimitModule?.withEdgeRateLimit) {
    try {
      const cfg = rateLimitModule.RATE_LIMIT_CONFIGS?.AUTH ?? {
        limit: 10,
        windowMs: 300_000,
      };

      const { allowed, result } = await rateLimitModule.withEdgeRateLimit(req, cfg);
      if (!allowed) {
        console.warn(`[AdminLogin] Rate limited via unified: ${clientIp}`);
        return result 
          ? { limited: true, result }
          : { limited: true };
      }
      rateLimitResult = result;
    } catch (error) {
      console.warn("[AdminLogin] Unified rate limit error:", error);
    }
  }

  return { limited: false, result: rateLimitResult };
}

// ==================== PASSWORD VERIFICATION ====================
async function verifyPassword(inputPassword: string, storedHash: string): Promise<boolean> {
  // Primary: bcrypt
  try {
    const { compare } = await import("bcryptjs");
    return await compare(inputPassword, storedHash);
  } catch (error) {
    console.warn("[Auth] bcrypt not available, using fallback:", error);
    
    // Development fallback (timing-safe comparison)
    if (process.env.NODE_ENV === "development") {
      const input = toUint8Array(inputPassword);
      const expected = toUint8Array(process.env.ADMIN_DEV_PASSWORD || "");
      
      if (input.length !== expected.length) return false;
      return timingSafeEqualBytes(input, expected);
    }
    
    // Production: must fail if bcrypt is unavailable
    throw new Error("Password verification failed: bcrypt not available");
  }
}

// ==================== AUDIT LOGGING ====================
async function logFailedAttempt(
  username: string,
  reason: string,
  userId?: string,
  clientIp?: string,
  userAgent?: string
): Promise<void> {
  try {
    await auditLogger.log({
      action: "LOGIN_FAILED",
      actorId: userId || "unknown",
      actorType: "user",
      actorEmail: username,
      category: "auth",
      severity: "warning",
      details: {
        reason,
        threatType: "failed_auth",
        sourceIp: clientIp || "unknown",
        userAgent: userAgent || "unknown",
      },
      ipAddress: clientIp || "unknown",
      userAgent: userAgent || "unknown",
      status: "failure",
    });
  } catch (error) {
    console.error("[AuthLog] Failed to log failed attempt:", error);
  }
}

async function logSuccessfulLogin(
  userId: string,
  username: string,
  clientIp?: string,
  userAgent?: string,
  mfaUsed: boolean = false
): Promise<void> {
  try {
    await auditLogger.log({
      action: "LOGIN_SUCCESS",
      actorId: userId,
      actorType: "user",
      actorEmail: username,
      category: "auth",
      severity: "info",
      details: {
        method: "password",
        mfaUsed,
        sourceIp: clientIp || "unknown",
        userAgent: userAgent || "unknown",
      },
      ipAddress: clientIp || "unknown",
      userAgent: userAgent || "unknown",
      status: "success",
    });
  } catch (error) {
    console.error("[AuthLog] Failed to log successful login:", error);
  }
}

async function logMfaChallengeCreated(
  userId: string,
  username: string,
  clientIp?: string,
  userAgent?: string
): Promise<void> {
  try {
    await auditLogger.log({
      action: "MFA_CHALLENGE_CREATED",
      actorId: userId,
      actorType: "user",
      actorEmail: username,
      category: "auth",
      severity: "info",
      details: {
        method: "password",
        mfaRequired: true,
        sourceIp: clientIp || "unknown",
        userAgent: userAgent || "unknown",
      },
      ipAddress: clientIp || "unknown",
      userAgent: userAgent || "unknown",
      status: "success",
    });
  } catch (error) {
    console.error("[AuthLog] Failed to log MFA challenge:", error);
  }
}

// ==================== AUTHENTICATION SERVICE ====================
async function authenticateAdmin(
  username: string,
  password: string,
  clientIp?: string,
  userAgent?: string
): Promise<AuthResult> {
  try {
    // Try central auth utility first
    try {
      const { verifyAdminCredentials } = await import("@/lib/server/auth/admin-utils");
      return await verifyAdminCredentials(username, password);
    } catch (error) {
      console.warn("[AdminAuth] Central auth utility not available, using direct DB check");
    }

    // Fallback: direct database authentication
    const { prisma } = await import("@/lib/prisma");
    
    const user = await prisma.adminUser.findUnique({
      where: { username: username.toLowerCase() },
      select: {
        id: true,
        username: true,
        passwordHash: true,
        role: true,
        permissions: true,
        mfaEnabled: true,
        status: true,
        lastLoginAt: true,
        failedLoginAttempts: true,
      },
    });

    if (!user) {
      await logFailedAttempt(username, "user_not_found", undefined, clientIp, userAgent);
      return { success: false, error: "Invalid credentials" };
    }

    // Check account status
    if (user.status === "locked" || (user.failedLoginAttempts && user.failedLoginAttempts >= 5)) {
      return {
        success: false,
        error: "Account is temporarily locked. Please contact support.",
      };
    }

    // Verify password
    const isPasswordValid = await verifyPassword(password, user.passwordHash!);

    if (!isPasswordValid) {
      // Increment failed attempts
      await prisma.adminUser.update({
        where: { id: user.id },
        data: {
          failedLoginAttempts: { increment: 1 },
          lastFailedLoginAt: new Date(),
        },
      });

      await logFailedAttempt(username, "invalid_password", user.id, clientIp, userAgent);
      return { success: false, error: "Invalid credentials" };
    }

    // Reset failed attempts and update last login
    await prisma.adminUser.update({
      where: { id: user.id },
      data: {
        failedLoginAttempts: 0,
        lastLoginAt: new Date(),
      },
    });

    // Parse permissions if stored as JSON string
    const permissions = typeof user.permissions === "string" 
      ? JSON.parse(user.permissions || "[]")
      : (user.permissions || []);

    const adminUser: AdminUser = {
      id: user.id,
      username: user.username,
      role: user.role as "admin" | "superadmin" | "editor",
      permissions,
      mfaEnabled: user.mfaEnabled,
    };

    return {
      success: true,
      user: adminUser,
      requiresMFA: user.mfaEnabled,
    };

  } catch (error) {
    console.error("[AdminAuth] Authentication error:", error);
    return { success: false, error: "Authentication failed" };
  }
}

// ==================== SESSION MANAGEMENT ====================
async function createAdminSession(
  user: AdminUser,
  userAgent?: string,
  ipAddress?: string
): Promise<SessionResult> {
  try {
    // Try to use centralized session management
    const sessionModule = await safeImport<any>("@/lib/auth/sessions");
    
    if (sessionModule?.createSession) {
      // Infer the expected options type from the real function signature
      type CreateSessionOptions = Parameters<typeof sessionModule.createSession>[0];
      
      // Build session options with inferred type safety
      const sessionOptions: CreateSessionOptions = {
        userId: user.id,
        username: user.username,
        role: user.role,
        permissions: user.permissions,
        mfaEnabled: user.mfaEnabled,
        userAgent: userAgent || "admin-login",
        ipAddress: ipAddress || "unknown",
        metadata: {
          source: "admin-login-api",
          loginMethod: "password",
          timestamp: new Date().toISOString(),
        },
        expiresIn: 30 * 24 * 60 * 60, // 30 days in seconds
      } as CreateSessionOptions;

      const session = await sessionModule.createSession(sessionOptions);
      
      // Ensure the session has required fields
      if (session?.token && session?.userId) {
        return {
          token: session.token,
          csrfToken: session.csrfToken,
          userId: session.userId,
          expiresAt: session.expiresAt,
        };
      }
    }

    // Fallback: create database session directly
    console.warn("[Session] Centralized session creation not available, using fallback");
    
    const sessionId = randomBytes(32).toString("hex");
    const csrfToken = randomBytes(16).toString("hex");
    const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days

    const { prisma } = await import("@/lib/prisma");
    
    await prisma.adminSession.create({
      data: {
        id: sessionId,
        userId: user.id,
        token: sessionId,
        csrfToken,
        expiresAt,
        userAgent: userAgent || "admin-login",
        ipAddress: ipAddress || "unknown",
        metadata: {
          username: user.username,
          role: user.role,
          mfaEnabled: user.mfaEnabled,
          source: "fallback-session",
        },
      },
    });

    return {
      token: sessionId,
      csrfToken,
      userId: user.id,
      expiresAt,
    };

  } catch (error) {
    console.error("[Session] Failed to create session:", error);
    throw new Error("Session creation failed");
  }
}

async function setMFAChallenge(userId: string, challenge: string): Promise<void> {
  try {
    // Try to use MFA module if available
    const mfaModule = await safeImport<any>("@/lib/auth/mfa");
    
    if (mfaModule?.setMFAChallenge) {
      await mfaModule.setMFAChallenge(userId, challenge);
      return;
    }

    console.warn("[MFA] MFA module not available, using database fallback");

    // Fallback: store in database with expiry
    const { prisma } = await import("@/lib/prisma");
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    await prisma.mfaChallenge.upsert({
      where: { userId },
      update: { challenge, expiresAt, used: false },
      create: {
        userId,
        challenge,
        expiresAt,
        used: false,
      },
    });
  } catch (error) {
    console.error("[MFA] Failed to set challenge:", error);
    throw new Error("Failed to create MFA challenge");
  }
}

// ==================== MAIN HANDLER ====================
export async function POST(request: NextRequest): Promise<NextResponse> {
  const startTime = Date.now();
  const clientIp = getClientIp(request);
  const userAgent = request.headers.get("user-agent") || "unknown";

  try {
    // Load rate limiters
    const { rateLimitRedis, rateLimitModule } = await loadRateLimiters();

    // Apply rate limiting
    const rateLimitCheck = await applyRateLimiting(
      request,
      clientIp,
      rateLimitRedis,
      rateLimitModule
    );

    if (rateLimitCheck.limited) {
      // Log rate limiting event
      await auditLogger.log({
        action: "RATE_LIMIT_EXCEEDED",
        category: "auth",
        severity: "warning",
        details: {
          threatType: "brute_force",
          sourceIp: clientIp,
          reason: "Too many login attempts",
          blocked: true,
        },
        ipAddress: clientIp,
        userAgent,
        status: "failure",
      });

      // Return rate limited response
      if (rateLimitModule?.createRateLimitedResponse && rateLimitCheck.result) {
        return rateLimitModule.createRateLimitedResponse(rateLimitCheck.result) as NextResponse;
      }

      return NextResponse.json(
        { error: "Too many login attempts. Please try again later." },
        {
          status: 429,
          headers: {
            "Retry-After": "300",
            "X-RateLimit-Reason": "too_many_attempts",
          },
        }
      );
    }

    // Parse and validate request body
    let body: any;
    try {
      body = await request.json();
    } catch (error) {
      await logFailedAttempt("unknown", "invalid_json", undefined, clientIp, userAgent);
      return jsonError("Invalid JSON", 400);
    }

    const username = normalizeUsername(body?.username);
    const password = normalizePassword(body?.password);
    const rememberMe = normalizeRememberMe(body?.rememberMe);

    if (!username || !password) {
      await logFailedAttempt(username || "unknown", "missing_credentials", undefined, clientIp, userAgent);
      return jsonError("Username and password required", 400);
    }

    if (username.length > 100 || password.length > 500) {
      await logFailedAttempt(username, "invalid_input_length", undefined, clientIp, userAgent);
      return jsonError("Invalid input length", 400);
    }

    // Authenticate user
    const authResult = await authenticateAdmin(username, password, clientIp, userAgent);

    if (!authResult.success) {
      // Add consistent timing delay
      const elapsed = Date.now() - startTime;
      const minDelay = 500;
      if (elapsed < minDelay) await sleep(minDelay - elapsed);

      return NextResponse.json(
        { error: authResult.error || "Invalid credentials" },
        { status: 401 }
      );
    }

    // Handle MFA if required
    if (authResult.requiresMFA) {
      const mfaChallenge = randomBytes(16).toString("hex");
      await setMFAChallenge(authResult.user!.id, mfaChallenge);
      
      await logMfaChallengeCreated(authResult.user!.id, username, clientIp, userAgent);

      return NextResponse.json({
        success: true,
        requiresMFA: true,
        userId: authResult.user!.id,
        challenge: mfaChallenge,
        username: authResult.user!.username,
      });
    }

    // Create session
    const session = await createAdminSession(authResult.user!, userAgent, clientIp);

    // Log successful login
    await logSuccessfulLogin(authResult.user!.id, username, clientIp, userAgent, false);

    // Build response
    const response = NextResponse.json({
      success: true,
      user: {
        id: authResult.user!.id,
        username: authResult.user!.username,
        role: authResult.user!.role,
        permissions: authResult.user!.permissions,
        mfaEnabled: authResult.user!.mfaEnabled,
      },
      session: {
        expiresIn: 30 * 24 * 60 * 60, // 30 days in seconds
        expiresAt: session.expiresAt?.toISOString(),
      },
    }, { status: 200 });

    // Set cookies
    response.cookies.set("admin_session", session.token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      maxAge: rememberMe ? 30 * 24 * 60 * 60 : 24 * 60 * 60,
      path: "/",
      priority: "high",
    });

    if (session.csrfToken) {
      response.cookies.set("admin_csrf", session.csrfToken, {
        httpOnly: false,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
        maxAge: rememberMe ? 30 * 24 * 60 * 60 : 24 * 60 * 60,
        path: "/",
      });
    }

    // Security headers
    response.headers.set("X-Content-Type-Options", "nosniff");
    response.headers.set("Cache-Control", "no-store, no-cache, must-revalidate");
    response.headers.set("Pragma", "no-cache");
    response.headers.set("X-Frame-Options", "DENY");
    response.headers.set("X-XSS-Protection", "1; mode=block");
    response.headers.set("Strict-Transport-Security", "max-age=31536000; includeSubDomains");

    // Custom headers
    response.headers.set("X-Login-Success", "true");
    response.headers.set("X-User-Role", authResult.user!.role);
    response.headers.set("X-User-Id", authResult.user!.id);
    response.headers.set("X-Response-Time", `${Date.now() - startTime}ms`);

    // Rate limit headers if available
    if (rateLimitCheck.result && rateLimitModule?.createRateLimitHeaders) {
      try {
        const headers = rateLimitModule.createRateLimitHeaders(rateLimitCheck.result);
        Object.entries(headers).forEach(([key, value]) => {
          response.headers.set(key, String(value));
        });
      } catch (error) {
        console.warn("[AdminLogin] Failed to set rate limit headers:", error);
      }
    }

    console.log(`[AdminLogin] Successful login for ${username} in ${Date.now() - startTime}ms`);
    return response;

  } catch (error) {
    console.error("[AdminLogin] Internal server error:", error);
    
    // Log internal error
    await auditLogger.log({
      action: "LOGIN_INTERNAL_ERROR",
      category: "auth",
      severity: "error",
      details: {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
        sourceIp: clientIp,
      },
      ipAddress: clientIp,
      userAgent,
      status: "failure",
      metadata: {
        endpoint: "/api/admin/login",
        method: "POST",
        timestamp: new Date().toISOString(),
      },
    });

    return NextResponse.json(
      { error: "Internal server error" },
      {
        status: 500,
        headers: {
          "Cache-Control": "no-store",
          "X-Error-Type": "internal_error",
        },
      }
    );
  }
}

// ==================== SUPPORTING ENDPOINTS ====================
export async function GET(): Promise<NextResponse> {
  return NextResponse.json({
    recaptchaEnabled: !!process.env.NEXT_PUBLIC_RECAPTCHA_SITE_KEY,
    mfaEnabled: process.env.ADMIN_MFA_ENABLED === "true",
    allowRememberMe: true,
    maxPasswordLength: 500,
    minPasswordLength: 8,
    supportedAuthMethods: ["password", "mfa"],
    version: "1.0.0",
    timestamp: new Date().toISOString(),
  }, {
    status: 200,
    headers: {
      "Cache-Control": "public, max-age=3600",
      "X-Endpoint-Version": "admin-login-v1",
    },
  });
}

export async function HEAD(): Promise<NextResponse> {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Cache-Control": "no-store",
      "X-Status": "healthy",
      "X-Endpoint": "admin-login",
      "X-Timestamp": new Date().toISOString(),
    },
  });
}

// ==================== HEALTH CHECK ====================
export async function OPTIONS(): Promise<NextResponse> {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Allow": "GET, POST, HEAD, OPTIONS",
      "Access-Control-Allow-Methods": "GET, POST, HEAD, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Max-Age": "86400",
      "Cache-Control": "no-store",
    },
  });
}
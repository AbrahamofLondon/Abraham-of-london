// components/downloads/SafeDownloadLink.tsx
import * as React from "react";
import Link from "next/link";

type Props = React.PropsWithChildren<{ href: string; className?: string; fallbackHref?: string; }>;

let manifest: Set<string> | null = null;
function useManifest() {
  const [ok, setOk] = React.useState(false);
  React.useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        if (!manifest) {
          const res = await fetch("/downloads/manifest.json", { cache: "no-store" });
          if (res.ok) {
            const json = await res.json();
            manifest = new Set<string>(json.files || []);
          } else {
            manifest = new Set();
          }
        }
        if (!cancelled) setOk(true);
      } catch {
        manifest = new Set();
        if (!cancelled) setOk(true);
      }
    })();
    return () => { cancelled = true; };
  }, []);
  return { ready: ok, has: (file: string) => manifest?.has(file.replace(/^\/?downloads\//, "")) ?? false };
}

export default function SafeDownloadLink({ href, children, fallbackHref, className }: Props) {
  const { ready, has } = useManifest();
  const file = href.replace(/^\/+/, "");
  const good = ready ? has(file) || has(file.replace(/^downloads\//, "")) : true; // optimistic until ready
  const finalHref = good ? href : (fallbackHref ?? "#");

  return (
    <Link href={finalHref} prefetch={false} className={className} aria-disabled={!good}>
      {children}{!good && <span className="sr-only"> (temporarily unavailable)</span>}
    </Link>
  );
}

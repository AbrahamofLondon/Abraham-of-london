// lib/server/guards.ts
import type { NextApiRequest, NextApiResponse } from "next";
import {
  rateLimit,
  getClientIp,
  createRateLimitHeaders,
  RATE_LIMIT_CONFIGS,
} from "@/lib/server/rate-limit-unified";
import type { RateLimitOptions } from "@/lib/server/rate-limit-unified";
import { safeSlice } from "@/lib/utils/safe";


type BlockPayload = {
  ok: false;
  error: "RATE_LIMITED";
  message: string;
  retryAfter: number;
};

function getRetryAfterSeconds(result: unknown): number {
  const ms = (result as any)?.retryAfterMs;
  if (typeof ms === "number" && Number.isFinite(ms) && ms > 0) return Math.ceil(ms / 1000);
  return 60; // safe default
}

/**
 * guardRateLimit()
 * - keeps existing behavior
 * - safe against missing retryAfterMs typing
 */
export async function guardRateLimit(
  req: NextApiRequest,
  res: NextApiResponse,
  options: RateLimitOptions = RATE_LIMIT_CONFIGS.API_GENERAL,
  keySuffix?: string
): Promise<boolean> {
  const ip = getClientIp(req);
  const route = req.url || "/";
  const key = `${ip}:${route}:${keySuffix ?? "default"}`;

  const result = await rateLimit(key, options);

  const headers = createRateLimitHeaders(result as any);
  for (const [k, v] of Object.entries(headers)) res.setHeader(k, v as any);

  if ((result as any)?.allowed) return true;

  const payload: BlockPayload = {
    ok: false,
    error: "RATE_LIMITED",
    message: "Too many requests. Please slow down.",
    retryAfter: getRetryAfterSeconds(result),
  };

  res.status(429).json(payload);
  return false;
}

/**
 * withGuardRateLimit()
 * - preserves your wrapper pattern
 */
export function withGuardRateLimit(
  handler: (req: NextApiRequest, res: NextApiResponse) => Promise<void> | void,
  options: RateLimitOptions = RATE_LIMIT_CONFIGS.API_GENERAL,
  keySuffix?: string
) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    const ok = await guardRateLimit(req, res, options, keySuffix);
    if (!ok) return;
    return handler(req, res);
  };
}

/**
 * ✅ required exports used by your API routes
 * requireRateLimit: alias wrapper around guardRateLimit
 */
export async function requireRateLimit(
  req: NextApiRequest,
  res: NextApiResponse,
  options: RateLimitOptions = RATE_LIMIT_CONFIGS.API_GENERAL,
  keySuffix?: string
): Promise<boolean> {
  return guardRateLimit(req, res, options, keySuffix);
}

/**
 * ✅ required exports used by your admin routes
 * requireAdmin: minimal admin auth gate (header Bearer ADMIN_API_KEY).
 */
export async function requireAdmin(req: NextApiRequest, res: NextApiResponse): Promise<boolean> {
  const adminKey = (process.env.ADMIN_API_KEY || "").trim();

  if (!adminKey) {
    res.status(500).json({
      ok: false,
      error: "ADMIN_NOT_CONFIGURED",
      message: "ADMIN_API_KEY is missing from environment variables.",
    } as any);
    return false;
  }

  const auth = String(req.headers.authorization || "");
  const token = auth.startsWith("Bearer ") ? auth.slice(7).trim() : auth.trim();

  if (!token || token !== adminKey) {
    res.status(403).json({
      ok: false,
      error: "FORBIDDEN",
      message: "Admin access required.",
    } as any);
    return false;
  }

  return true;
}

export default {
  guardRateLimit,
  withGuardRateLimit,
  requireRateLimit,
  requireAdmin,
};
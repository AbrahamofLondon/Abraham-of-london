// next.config.mjs

import createMDX from "@next/mdx";
import remarkGfm from "remark-gfm";
import fs from "node:fs";
import path from "node:path";
import { createRequire } from "node:module";
import { withContentlayer } from "next-contentlayer2";

// ------------------------------------------------
// Environment Variables and Tool Setup
// ------------------------------------------------
const require = createRequire(import.meta.url);
const relax = process.env.CI_LAX === "1";
const isAnalyze = process.env.ANALYZE === "true";

// --- DYNAMIC REDIRECTS FUNCTION ---
// Loads redirects generated by the Global Project Manager script
async function getRedirects() {
    // Uses process.cwd() as it's the correct way to get the project root in ESM config
    const gen = path.join(process.cwd(), "config/redirects.generated.json");
    let auto = [];
    if (fs.existsSync(gen)) {
        try {
            auto = JSON.parse(fs.readFileSync(gen, "utf8"));
        } catch (e) {
            console.error("Error reading redirects.generated.json:", e.message);
        }
    }
    return [
        // ... Your static redirects (add them here if needed) ...
        // Example static redirect:
        // { source: '/old-resource', destination: '/resources/new-resource-slug', permanent: true },
        ...auto,
    ];
}
// ------------------------------------------------

const withMDX = createMDX({
    extension: /\.mdx?$/,
    options: { remarkPlugins: [remarkGfm] },
});

/** @type {import('next').NextConfig} */
const nextConfig = {
    // --- CORE CONFIG ---
    pageExtensions: ["js", "jsx", "ts", "tsx", "md", "mdx"],
    reactStrictMode: true,
    poweredByHeader: false,
    productionBrowserSourceMaps: false,
    
    // --- REDIRECTS: Dynamic and Static ---
    async redirects() { return getRedirects(); },

    // --- BUILD/ERROR HANDLING ---
    typescript: { 
        // Ignores TS build errors only if CI_LAX=1 is set
        ignoreBuildErrors: relax 
    },

    // --- IMAGE CONFIG ---
    images: {
        formats: ["image/avif", "image/webp"],
        dangerouslyAllowSVG: true,
        remotePatterns: [
            { protocol: "https", hostname: "abraham-of-london.netlify.app" },
            { protocol: "https", hostname: "abrahamoflondon.org" },
            { protocol: "https", hostname: "www.abrahamoflondon.org" },
        ],
    },
    
    // --- EXPERIMENTAL CONFIG ---
    experimental: {
        // Optimize imports for large libraries like Framer Motion
        optimizePackageImports: ["framer-motion"],
        // NOTE: Keys like 'turbopack', 'swcMinify', and 'appDir' are omitted as they are
        // either invalid in modern Next.js or set automatically.
    },
    
    // --- CUSTOM WEBPACK CONFIGURATION (For path aliases) ---
    webpack(config, { dev }) {
        // Defensive cleanup of rule usage (preserves original logic)
        config.module.rules = config.module.rules
            .map((rule) => {
                if (!rule || !rule.use) return rule;
                const arr = Array.isArray(rule.use) ? rule.use : [rule.use];
                const cleaned = arr
                    .filter(Boolean)
                    .map((u) => (typeof u === "string" ? { loader: u } : u))
                    .filter((u) => u && typeof u.loader === "string");
                if (cleaned.length === 0) return dev ? null : rule;
                return { ...rule, use: cleaned };
            })
            .filter(Boolean);

        // Path aliases
        config.resolve.alias = {
            ...(config.resolve.alias || {}),
            // Standard Next.js alias
            "@": path.resolve(process.cwd()), 
            // Specific Aliases
            "#/components": path.resolve(process.cwd(), "components"),
            "#/lib": path.resolve(process.cwd(), "lib"),
            "#/styles": path.resolve(process.cwd(), "styles"),
            "#/config": path.resolve(process.cwd(), "config"),
            // Contentlayer generation path
            "contentlayer/generated": path.resolve(process.cwd(), ".contentlayer/generated"), 
        };

        return config;
    },
};

// --- BUNDLE ANALYZER LOGIC ---
let withAnalyzer = (cfg) => cfg;
if (isAnalyze) {
    try {
        const analyzer = require("@next/bundle-analyzer").default ?? require("@next/bundle-analyzer");
        withAnalyzer = analyzer({ enabled: true });
    } catch {
        console.warn("Bundle Analyzer is enabled but the package is not installed.");
    }
}

// Export the composed configuration with Contentlayer, Analyzer, and MDX wrappers
export default withContentlayer(withAnalyzer(withMDX(nextConfig)));
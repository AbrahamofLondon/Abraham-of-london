// ./pages/blog/[slug].tsx

import * as React from 'react';
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { MDXRemote, type MDXRemoteSerializeResult } from 'next-mdx-remote';
import { serialize } from 'next-mdx-remote/serialize';
import { GetStaticPaths, GetStaticProps } from 'next';
import Image from 'next/image'; // Optimized image handling
import { format } from 'date-fns'; // Consistent date formatting

// Assume these shared components exist from previous transformations
import Layout from '@/components/Layout';
import SEOHead from '@/components/SEOHead';
// 1. IMPORT YOUR CUSTOM MDX COMPONENTS MAP
import { MDXComponents } from '@/components/mdx'; // ðŸ‘ˆ CRITICAL IMPORT

// --- Type Definitions ---

interface FrontMatter {
  title: string;
  date: string; // ISO string recommended
  excerpt?: string;
  image?: string;
  author?: string;
  readTime?: string;
  tags?: string[];
  // Add other relevant frontmatter fields here for type safety
}

interface BlogPostProps {
  frontmatter: FrontMatter;
  mdxSource: MDXRemoteSerializeResult;
}

// --- Data Fetching (Static Generation) ---

// 1. Get Static Paths
export const getStaticPaths: GetStaticPaths = async () => {
  const postsDirectory = path.join(process.cwd(), 'content', 'blog');
  
  // Ensure directory exists before reading
  if (!fs.existsSync(postsDirectory)) {
    console.warn(`Content directory not found: ${postsDirectory}`);
    return { paths: [], fallback: false };
  }

  const files = fs.readdirSync(postsDirectory);
    
  const paths = files
    .filter(filename => filename.endsWith('.mdx'))
    .map((filename) => ({
      params: { slug: filename.replace('.mdx', '') }
    }));
    
  return { paths, fallback: false };
}

// 2. Get Static Props
export const getStaticProps: GetStaticProps<BlogPostProps> = async ({ params }) => {
  const slug = params?.slug as string;
  const filePath = path.join(process.cwd(), 'content', 'blog', `${slug}.mdx`);
    
  try {
    const markdownWithMeta = fs.readFileSync(filePath, 'utf-8');
    const { data: frontmatter, content } = matter(markdownWithMeta);

    // Runtime check for required fields
    if (!frontmatter.title || !frontmatter.date) {
        console.warn(`MDX file ${slug}.mdx is missing title or date.`);
        return { notFound: true };
    }
        
    // Type-cast frontmatter for use in the component props
    const typedFrontmatter: FrontMatter = frontmatter as FrontMatter;

    // Serialize the content with frontmatter as scope for component access
    const mdxSource = await serialize(content, { 
      scope: typedFrontmatter,
      mdxOptions: {
        // Add any remark/rehype plugins here
      } 
    });

    return {
      props: {
        frontmatter: typedFrontmatter,
        mdxSource
      },
      // Revalidate after 1 hour (3600 seconds)
      revalidate: 3600, 
    };

  } catch (error) {
    // If file doesn't exist or error during parsing
    console.error(`Error processing MDX file for slug: ${slug}`, error);
    return { notFound: true };
  }
}

// --- Component Rendering ---

export default function BlogPost({ frontmatter, mdxSource }: BlogPostProps) {
  // Use date-fns for formatting
  const formattedDate = format(new Date(frontmatter.date), 'MMMM d, yyyy');
  const author = frontmatter.author || 'Abraham of London';
  
  const pageTitle = frontmatter.title;
  const pageDescription = frontmatter.excerpt || 'An essay from Abraham of London.';

  return (
    <Layout pageTitle={pageTitle} hideSocialStrip hideCTA>
      {/* Consistent SEO using the SEOHead component */}
      <SEOHead
        title={pageTitle}
        description={pageDescription}
        slug={`/blog/${frontmatter.title.toLowerCase().replace(/\s/g, '-')}`} // Simple slug fallback
        // Add more meta data like coverImage, tags, etc., from frontmatter
      />
      
      <article className="max-w-4xl mx-auto pt-12 pb-20 px-4 md:px-6">
        {/* Post Header */}
        <header className="mb-10 text-center">
          <h1 className="font-serif text-4xl font-extrabold text-deepCharcoal dark:text-cream sm:text-5xl md:text-6xl leading-tight">
            {frontmatter.title}
          </h1>
          <p className="mt-3 text-sm font-medium text-gray-500 dark:text-gray-400">
            By {author} | <time dateTime={frontmatter.date}>{formattedDate}</time>
            {frontmatter.readTime && <span className="ml-2">| {frontmatter.readTime} Read</span>}
          </p>
        </header>

        {/* Feature Image (Optimized with next/image) */}
        {frontmatter.image && (
          <div className="relative w-full h-80 mb-10 overflow-hidden rounded-2xl shadow-xl">
            <Image
              src={frontmatter.image}
              alt={frontmatter.title}
              fill
              style={{ objectFit: 'cover' }}
              className="transition-transform duration-500 hover:scale-105"
              priority // Feature image is typically LCP
              sizes="(max-width: 1024px) 100vw, 800px"
            />
          </div>
        )}
        
        {/* MDX Content */}
        <div className="prose prose-lg dark:prose-invert mx-auto max-w-3xl text-deepCharcoal dark:text-lightGrey">
          <MDXRemote 
            {...mdxSource} 
            components={MDXComponents} // Pass the custom component map
          />
        </div>

      </article>
    </Layout>
  );
}
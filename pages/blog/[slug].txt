// pages/[slug].tsx - UPDATED WITH BOOKS FIX
import * as React from "react";
import Head from "next/head";
import { useRouter } from "next/router";
import type { GetStaticPaths, GetStaticProps } from "next";
import {
  MDXRemote,
  type MDXRemoteSerializeResult,
} from "next-mdx-remote";
import { serialize } from "next-mdx-remote/serialize";

import Layout from "@/components/Layout";
import mdxComponents from "@/components/mdx-components";
import { getAllContent, getContentBySlug } from "@/lib/mdx"; 
import { getAllPosts, getPostBySlug } from "@/lib/posts"; 
import { getAllBooksMeta, getBookBySlug } from "@/lib/server/books-data"; // ADDED
import type { PostMeta } from "@/types/post";
import ArticleHero from "@/components/ArticleHero";
import Comments from "@/components/Comments";

type PageMeta = PostMeta & {
  coverAspect?: "book" | "wide" | "square";
  coverFit?: "cover" | "contain";
  toc?: boolean;
  related?: string[];
  format?: "hardcover" | "paperback" | "ebook" | "audiobook"; // ADDED FOR BOOKS
  isbn?: string; // ADDED FOR BOOKS
  publisher?: string; // ADDED FOR BOOKS
};

type PageProps = {
  meta: PageMeta;
  mdxSource: MDXRemoteSerializeResult;
  contentKind: string;
  estimatedReadingTime?: number;
};

// Define collections - ADDED BOOKS
const BLOG_COLLECTION = "Post";
const BOOK_COLLECTION = "Book"; // NEW
const FALLBACK_COLLECTIONS = ["Print", "Resource", "Page"] as const;
const ALL_COLLECTIONS = [BLOG_COLLECTION, BOOK_COLLECTION, ...FALLBACK_COLLECTIONS];

// -----------------------------------------------------------------------------
// Custom hook for reading progress
// -----------------------------------------------------------------------------
const useReadingProgress = () => {
  const [progress, setProgress] = React.useState(0);
  
  React.useEffect(() => {
    const updateProgress = () => {
      const article = document.querySelector("article");
      if (!article) return;
      
      const articleRect = article.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      const documentHeight = document.documentElement.scrollHeight;
      
      const scrolled = window.scrollY;
      const totalHeight = documentHeight - windowHeight;
      
      const progress = totalHeight > 0 ? (scrolled / totalHeight) * 100 : 0;
      setProgress(Math.min(100, Math.max(0, progress)));
    };
    
    window.addEventListener("scroll", updateProgress);
    window.addEventListener("resize", updateProgress);
    updateProgress();
    
    return () => {
      window.removeEventListener("scroll", updateProgress);
      window.removeEventListener("resize", updateProgress);
    };
  }, []);
  
  return progress;
};

// -----------------------------------------------------------------------------
// Page component
// -----------------------------------------------------------------------------

function ContentPage({ meta, mdxSource, contentKind, estimatedReadingTime }: PageProps): JSX.Element {
  const router = useRouter();
  const readingProgress = useReadingProgress();
  
  const {
    title,
    description,
    excerpt,
    category,
    tags = [],
    date,
    readTime,
    coverImage,
    coverAspect,
    coverFit,
    toc = false,
    related = [],
    format, // BOOK SPECIFIC
    isbn, // BOOK SPECIFIC
    publisher, // BOOK SPECIFIC
  } = meta;

  const displayReadTime = estimatedReadingTime || readTime || 5;
  const displaySubtitle = excerpt || description || undefined;
  
  const primaryCategory = React.useMemo(() => {
    if (category) return category;
    if (Array.isArray(tags) && tags.length > 0) {
      return typeof tags[0] === 'string' ? tags[0] : 'Article';
    }
    return contentKind === BOOK_COLLECTION ? "Book" : "Article";
  }, [category, tags, contentKind]);

  const canonicalTitle = title || "Abraham of London";
  const displayDescription = description || excerpt || "";
  
  const showComments = contentKind === BLOG_COLLECTION;
  const showTOC = toc && (contentKind === BLOG_COLLECTION || contentKind === BOOK_COLLECTION);
  const isBook = contentKind === BOOK_COLLECTION;

  return (
    <Layout title={canonicalTitle}>
      <Head>
        <title>{canonicalTitle} | Abraham of London</title>
        <meta name="description" content={displayDescription} />
        
        {/* Open Graph Meta Tags */}
        <meta property="og:title" content={canonicalTitle} />
        <meta property="og:description" content={displayDescription} />
        <meta property="og:type" content={isBook ? "book" : contentKind === BLOG_COLLECTION ? "article" : "website"} />
        <meta property="og:url" content={`https://abrahamoflondon.com${router.asPath}`} />
        {coverImage && <meta property="og:image" content={coverImage as string} />}
        
        {/* Twitter Card */}
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content={canonicalTitle} />
        <meta name="twitter:description" content={displayDescription} />
        {coverImage && <meta name="twitter:image" content={coverImage as string} />}
        
        {/* Structured Data - Enhanced for Books */}
        {isBook ? (
          <script
            type="application/ld+json"
            dangerouslySetInnerHTML={{
              __html: JSON.stringify({
                "@context": "https://schema.org",
                "@type": "Book",
                name: canonicalTitle,
                description: displayDescription,
                image: coverImage,
                datePublished: date,
                author: {
                  "@type": "Person",
                  name: meta.author || "Abraham of London"
                },
                publisher: publisher ? {
                  "@type": "Organization",
                  name: publisher
                } : undefined,
                isbn: isbn,
                bookFormat: format ? `https://schema.org/${format}` : undefined,
                inLanguage: meta.language || "en-GB"
              })
            }}
          />
        ) : contentKind === BLOG_COLLECTION ? (
          <script
            type="application/ld+json"
            dangerouslySetInnerHTML={{
              __html: JSON.stringify({
                "@context": "https://schema.org",
                "@type": "BlogPosting",
                headline: canonicalTitle,
                description: displayDescription,
                image: coverImage,
                datePublished: date,
                author: {
                  "@type": "Person",
                  name: "Abraham of London"
                }
              })
            }}
          />
        ) : null}
      </Head>

      <ArticleHero
        title={title}
        subtitle={displaySubtitle}
        category={primaryCategory}
        date={date}
        readTime={displayReadTime}
        coverImage={coverImage as string | undefined}
        coverAspect={coverAspect}
        coverFit={coverFit}
        // ADD BOOK-SPECIFIC BADGE
        badges={isBook ? [
          { text: format || "Book", color: "amber" },
          ...(publisher ? [{ text: publisher, color: "gray" }] : [])
        ] : []}
      />

      <main className="relative">
        <div className="mx-auto w-full max-w-7xl px-4 lg:px-8">
          <div className="flex flex-col lg:flex-row gap-8 lg:gap-12">
            {showTOC && (
              <aside className="lg:w-64 flex-shrink-0 hidden lg:block">
                <div className="sticky top-32">
                  <div className="border-l-2 border-softGold pl-4">
                    <h3 className="font-semibold text-aol-text dark:text-cream mb-3">
                      Contents
                    </h3>
                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                      {isBook ? "Book chapters" : "Article sections"}
                    </p>
                  </div>
                </div>
              </aside>
            )}

            <div className="flex-1 min-w-0">
              <article className="max-w-3xl mx-auto pb-16 pt-10">
                {/* Book-specific metadata */}
                {isBook && (
                  <div className="mb-8 p-6 bg-aol-bg-subtle dark:bg-gray-900 rounded-xl border border-aol-border-subtle">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      {isbn && (
                        <div>
                          <span className="text-sm font-medium text-gray-500 dark:text-gray-400">ISBN:</span>
                          <p className="text-aol-text dark:text-cream">{isbn}</p>
                        </div>
                      )}
                      {format && (
                        <div>
                          <span className="text-sm font-medium text-gray-500 dark:text-gray-400">Format:</span>
                          <p className="text-aol-text dark:text-cream capitalize">{format}</p>
                        </div>
                      )}
                      {publisher && (
                        <div>
                          <span className="text-sm font-medium text-gray-500 dark:text-gray-400">Publisher:</span>
                          <p className="text-aol-text dark:text-cream">{publisher}</p>
                        </div>
                      )}
                      {meta.publishedDate && (
                        <div>
                          <span className="text-sm font-medium text-gray-500 dark:text-gray-400">Published:</span>
                          <p className="text-aol-text dark:text-cream">
                            {new Date(meta.publishedDate).toLocaleDateString('en-GB', {
                              year: 'numeric',
                              month: 'long',
                              day: 'numeric'
                            })}
                          </p>
                        </div>
                      )}
                    </div>
                  </div>
                )}

                <div className="prose prose-lg max-w-none dark:prose-invert">
                  <MDXRemote {...mdxSource} components={mdxComponents} />
                </div>

                {/* Book purchase link */}
                {isBook && meta.purchaseLink && (
                  <div className="mt-12 p-6 bg-gradient-to-r from-softGold/10 to-amber-500/10 rounded-xl border border-softGold/20">
                    <h3 className="text-xl font-serif font-semibold text-aol-text dark:text-cream mb-4">
                      Get This Book
                    </h3>
                    <a
                      href={meta.purchaseLink}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="inline-flex items-center gap-2 px-6 py-3 bg-softGold text-white rounded-lg hover:bg-amber-600 transition-colors"
                    >
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
                      </svg>
                      Purchase Now
                    </a>
                  </div>
                )}

                {/* Render Comments section only for blog posts */}
                {showComments && (
                  <div className="mt-20 pt-10 border-t border-aol-border-subtle dark:border-white/10">
                    <div className="max-w-2xl mx-auto">
                      <h3 className="text-2xl font-serif font-semibold text-aol-text dark:text-cream mb-6">
                        Join the Conversation
                      </h3>
                      <Comments 
                        issueTerm="pathname"
                        label="discussion" 
                        theme="preferred_color_scheme"
                        loading="lazy"
                      />
                    </div>
                  </div>
                )}
              </article>
            </div>
          </div>
        </div>
      </main>
    </Layout>
  );
}

export default ContentPage;

// -----------------------------------------------------------------------------
// SSG – paths
// -----------------------------------------------------------------------------

export const getStaticPaths: GetStaticPaths = async () => {
  try {
    const allItems: Array<{ slug: string; collection?: string }> = [];

    // Fetch blog posts
    const posts = await getAllPosts();
    allItems.push(...posts.map(post => ({ 
      slug: post.slug, 
      collection: BLOG_COLLECTION 
    })));

    // Fetch books
    const books = getAllBooksMeta();
    allItems.push(...books.map(book => ({ 
      slug: book.slug, 
      collection: BOOK_COLLECTION 
    })));

    // Gather slugs from fallback collections
    for (const key of FALLBACK_COLLECTIONS) {
      const items = getAllContent(key) ?? [];
      items.forEach(item => {
        if (item?.slug) {
          allItems.push({ 
            slug: String(item.slug), 
            collection: key 
          });
        }
      });
    }

    // Deduplicate slugs
    const seen = new Set<string>();
    const paths = allItems
      .filter(item => item?.slug)
      .map(item => String(item.slug))
      .filter(slug => {
        if (seen.has(slug)) {
          console.warn(`Duplicate slug detected: ${slug}`);
          return false;
        }
        seen.add(slug);
        return true;
      })
      .map(slug => ({ params: { slug } }));

    console.log(`Generated ${paths.length} static paths for /[slug]`);
    
    return {
      paths,
      fallback: "blocking",
    };
  } catch (err) {
    console.error("Error generating static paths for /[slug]:", err);
    return { paths: [], fallback: "blocking" };
  }
};

// -----------------------------------------------------------------------------
// SSG – props
// -----------------------------------------------------------------------------

export const getStaticProps: GetStaticProps<PageProps> = async ({ params }) => {
  try {
    const slugParam = params?.slug;
    const slug = typeof slugParam === "string"
      ? slugParam
      : Array.isArray(slugParam)
      ? slugParam[0]
      : "";

    if (!slug) {
      return { notFound: true };
    }

    let data: (PageMeta & { content?: string }) | null = null;
    let contentKind: string | null = null;

    // 1. Try Blog Post first
    const postCandidate = await getPostBySlug(slug);
    if (postCandidate) {
      data = postCandidate as PageMeta & { content?: string };
      contentKind = BLOG_COLLECTION;
    }

    // 2. Try Book second
    if (!data) {
      const bookCandidate = getBookBySlug(slug);
      if (bookCandidate) {
        data = bookCandidate as PageMeta & { content?: string };
        contentKind = BOOK_COLLECTION;
      }
    }

    // 3. If no post or book found, try Fallback Collections
    if (!data) {
      for (const key of FALLBACK_COLLECTIONS) {
        const candidate = getContentBySlug(key, slug, {
          withContent: true,
        }) as (PageMeta & { content?: string }) | null;

        if (candidate) {
          data = candidate;
          contentKind = key;
          break;
        }
      }
    }

    if (!data || !contentKind) {
      console.warn(`No content found for slug: ${slug}`);
      return { notFound: true };
    }

    const { content, ...meta } = data;

    if (!meta.title) {
      return { notFound: true };
    }

    const jsonSafeMeta = JSON.parse(JSON.stringify(meta)) as PageMeta;

    const mdxSource = await serialize(content || "", {
      scope: jsonSafeMeta as unknown as Record<string, unknown>,
      mdxOptions: {
        remarkPlugins: [],
        rehypePlugins: [],
      },
      parseFrontmatter: false,
    });

    return {
      props: {
        meta: jsonSafeMeta,
        mdxSource,
        contentKind,
      },
      revalidate: process.env.NODE_ENV === 'production' ? 3600 : 60,
    };
  } catch (err) {
    console.error("Error in getStaticProps for /[slug]:", err);
    return { notFound: true };
  }
};
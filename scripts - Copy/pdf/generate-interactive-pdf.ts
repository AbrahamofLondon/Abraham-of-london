// scripts/pdf/generate-interactive-pdf.ts - ENHANCED WITH LIBREOFFICE SUPPORT
import fs from "fs/promises";
import path from "path";
import { PDFDocument, StandardFonts, rgb, PDFPage } from "pdf-lib";
import { fileURLToPath } from "url";
import { exec } from "child_process";
import { promisify } from "util";
import { PDF_CONFIG, type BuildTier, type Quality, type Format } from "./constants.js";

const __filename = fileURLToPath(import.meta.url);
const execAsync = promisify(exec);

interface InteractivePDFConfig {
  format: Format;
  quality: Quality;
  tier: BuildTier;
  outputDir: string;
  includeInstructions?: boolean;
  watermarked?: boolean;
  version?: string;
  metadata?: Record<string, any>;
  useLibreOffice?: boolean;
  libreOfficePath?: string;
}

interface GenerationResult {
  success: boolean;
  filePath?: string;
  size?: number;
  error?: string;
  metadata?: {
    fieldCount: number;
    tier: BuildTier;
    format: Format;
    quality: Quality;
    generatedAt: string;
    method: 'pdf-lib' | 'libreoffice';
  };
}

interface LibreOfficeOptions {
  enabled: boolean;
  path?: string;
  timeout?: number; // ms
  verbose?: boolean;
}

function pageSize(format: Format): { width: number; height: number } {
  const sizes = {
    A4: { width: 595.28, height: 841.89 },
    Letter: { width: 612, height: 792 },
    A3: { width: 841.89, height: 1190.55 }
  };
  return sizes[format] || sizes.A4;
}

function normalizeFormat(s: string): Format {
  const v = String(s || "").trim().toUpperCase();
  return (v === "A4" || v === "LETTER" || v === "A3") ? v as Format : "A4";
}

function tierColor(tier: BuildTier): [number, number, number] {
  const colors = {
    free: [0.3, 0.3, 0.3] as [number, number, number],
    member: [0.1, 0.4, 0.7] as [number, number, number],
    architect: [0.8, 0.6, 0.2] as [number, number, number],
    'inner-circle': [0.6, 0.3, 0.9] as [number, number, number]
  };
  return colors[tier] || colors.architect;
}

// LibreOffice utility class
class LibreOfficeHelper {
  static async isAvailable(customPath?: string): Promise<{ available: boolean; path?: string; version?: string }> {
    try {
      const command = process.platform === 'win32' 
        ? `${customPath || 'soffice'} --version`
        : `${customPath || 'libreoffice'} --version`;
      
      const { stdout, stderr } = await execAsync(command, { timeout: 5000 });
      
      if (stderr && !stderr.includes('Warning')) {
        console.warn(`LibreOffice warning: ${stderr}`);
      }
      
      const versionMatch = stdout.match(/(\d+\.\d+\.\d+)/);
      const version = versionMatch ? versionMatch[1] : 'unknown';
      
      console.log(`‚úÖ LibreOffice detected: ${version}`);
      return { available: true, path: customPath || 'libreoffice', version };
    } catch (error) {
      console.log(`‚ö†Ô∏è LibreOffice not available: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return { available: false };
    }
  }

  static async generatePDFFromODT(
    odtTemplatePath: string,
    outputPdfPath: string,
    options: {
      libreOfficePath?: string;
      timeout?: number;
      verbose?: boolean;
    } = {}
  ): Promise<boolean> {
    try {
      // Check if template exists
      if (!fs.access(odtTemplatePath).then(() => true).catch(() => false)) {
        throw new Error(`ODT template not found: ${odtTemplatePath}`);
      }

      const cmd = process.platform === 'win32'
        ? `"${options.libreOfficePath || 'soffice'}" --headless --convert-to pdf --outdir "${path.dirname(outputPdfPath)}" "${odtTemplatePath}"`
        : `${options.libreOfficePath || 'libreoffice'} --headless --convert-to pdf --outdir "${path.dirname(outputPdfPath)}" "${odtTemplatePath}"`;

      if (options.verbose) {
        console.log(`Running LibreOffice command: ${cmd}`);
      }

      const { stdout, stderr } = await execAsync(cmd, {
        timeout: options.timeout || 30000,
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer
      });

      if (options.verbose) {
        if (stdout) console.log(`LibreOffice stdout: ${stdout}`);
        if (stderr && !stderr.includes('Info')) console.warn(`LibreOffice stderr: ${stderr}`);
      }

      // Check if PDF was created
      const expectedPdfPath = outputPdfPath.replace(/\.odt$/, '.pdf');
      const exists = await fs.access(expectedPdfPath).then(() => true).catch(() => false);
      
      if (exists) {
        // Rename to desired output path if needed
        if (expectedPdfPath !== outputPdfPath) {
          await fs.rename(expectedPdfPath, outputPdfPath);
        }
        console.log(`‚úÖ LibreOffice generated PDF: ${path.basename(outputPdfPath)}`);
        return true;
      } else {
        throw new Error('PDF not generated by LibreOffice');
      }
    } catch (error) {
      console.error(`‚ùå LibreOffice conversion failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return false;
    }
  }
}

// Simple console logger
const logger = {
  info: (msg: string) => console.log(`üìÑ ${msg}`),
  success: (msg: string) => console.log(`‚úÖ ${msg}`),
  error: (msg: string) => console.error(`‚ùå ${msg}`),
  warn: (msg: string) => console.warn(`‚ö†Ô∏è ${msg}`)
};

class InteractivePDFGenerator {
  private config: InteractivePDFConfig;
  private libreOfficeOptions: LibreOfficeOptions;
  
  constructor(config: InteractivePDFConfig) {
    this.config = {
      includeInstructions: true,
      watermarked: true,
      version: '1.0.0',
      useLibreOffice: false,
      ...config
    };
    
    this.libreOfficeOptions = {
      enabled: this.config.useLibreOffice || false,
      path: this.config.libreOfficePath,
      timeout: 30000,
      verbose: process.env.NODE_ENV === 'development'
    };
  }

  async generate(): Promise<GenerationResult> {
    const startTime = Date.now();
    
    try {
      const { format, quality, tier, outputDir, includeInstructions, watermarked, version, metadata } = this.config;
      const displayTier = PDF_CONFIG.tiers[tier].display;
      
      logger.info(`Generating interactive ${format} PDF (${quality} quality, ${tier} tier)...`);
      
      // Check LibreOffice availability if enabled
      let useLibreOffice = this.libreOfficeOptions.enabled;
      if (useLibreOffice) {
        const loCheck = await LibreOfficeHelper.isAvailable(this.libreOfficeOptions.path);
        if (!loCheck.available) {
          logger.warn('LibreOffice not available, falling back to pdf-lib');
          useLibreOffice = false;
        } else {
          logger.info(`Using LibreOffice ${loCheck.version} for PDF generation`);
        }
      }
      
      let result: GenerationResult;
      
      if (useLibreOffice) {
        result = await this.generateWithLibreOffice(startTime);
      } else {
        result = await this.generateWithPdfLib(startTime);
      }
      
      return result;
      
    } catch (error: any) {
      logger.error(`Generation failed: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }

  private async generateWithPdfLib(startTime: number): Promise<GenerationResult> {
    const { format, quality, tier, outputDir, includeInstructions, watermarked, version, metadata } = this.config;
    const displayTier = PDF_CONFIG.tiers[tier].display;
    
    // Create PDF document
    const pdfDoc = await PDFDocument.create();
    
    // Set comprehensive metadata
    this.setDocumentMetadata(pdfDoc, format, displayTier, quality, version);
    
    // Add page
    const { width, height } = pageSize(format);
    const page = pdfDoc.addPage([width, height]);
    
    // Embed fonts
    const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    
    // Draw document
    this.drawDocument(pdfDoc, page, {
      width, height, format, tier, quality, displayTier,
      helvetica, helveticaBold,
      includeInstructions, watermarked, metadata
    });
    
    // Create form
    const form = pdfDoc.getForm();
    const fieldCount = this.addInteractiveFields(form, page, {
      width, height, tier, helvetica
    });
    
    // Update field appearances
    form.updateFieldAppearances(helvetica);
    
    // Save PDF
    const pdfBytes = await pdfDoc.save();
    
    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });
    
    // Generate filename
    const fileName = `legacy-architecture-canvas-${format.toLowerCase()}-${quality}-${tier}-interactive.pdf`;
    const filePath = path.join(outputDir, fileName);
    
    // Write file
    await fs.writeFile(filePath, pdfBytes);
    
    // Get file stats
    const stats = await fs.stat(filePath);
    const duration = Date.now() - startTime;
    
    logger.success(`Generated with pdf-lib: ${fileName} (${(stats.size / 1024).toFixed(1)} KB, ${duration}ms)`);
    
    return {
      success: true,
      filePath,
      size: stats.size,
      metadata: {
        fieldCount,
        tier,
        format,
        quality,
        generatedAt: new Date().toISOString(),
        method: 'pdf-lib'
      }
    };
  }

  private async generateWithLibreOffice(startTime: number): Promise<GenerationResult> {
    const { format, quality, tier, outputDir, version, metadata } = this.config;
    const displayTier = PDF_CONFIG.tiers[tier].display;
    
    // Check for ODT template
    const templateDir = path.join(process.cwd(), 'templates', 'interactive-pdfs');
    const templateName = `legacy-architecture-canvas-${format.toLowerCase()}-${tier}.odt`;
    const templatePath = path.join(templateDir, templateName);
    
    // Fallback to default template if specific one doesn't exist
    const defaultTemplatePath = path.join(templateDir, 'legacy-architecture-canvas-template.odt');
    
    let odtTemplatePath = templatePath;
    if (!(await fs.access(templatePath).then(() => true).catch(() => false))) {
      if (await fs.access(defaultTemplatePath).then(() => true).catch(() => false)) {
        logger.warn(`Specific template not found, using default: ${path.basename(defaultTemplatePath)}`);
        odtTemplatePath = defaultTemplatePath;
      } else {
        throw new Error(`No ODT template found. Expected at: ${templatePath} or ${defaultTemplatePath}`);
      }
    }
    
    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });
    
    // Generate filename
    const fileName = `legacy-architecture-canvas-${format.toLowerCase()}-${quality}-${tier}-interactive-libreoffice.pdf`;
    const filePath = path.join(outputDir, fileName);
    
    // Generate PDF using LibreOffice
    const success = await LibreOfficeHelper.generatePDFFromODT(
      odtTemplatePath,
      filePath,
      {
        libreOfficePath: this.libreOfficeOptions.path,
        timeout: this.libreOfficeOptions.timeout,
        verbose: this.libreOfficeOptions.verbose
      }
    );
    
    if (!success) {
      throw new Error('LibreOffice PDF generation failed');
    }
    
    // Get file stats
    const stats = await fs.stat(filePath);
    const duration = Date.now() - startTime;
    
    logger.success(`Generated with LibreOffice: ${fileName} (${(stats.size / 1024).toFixed(1)} KB, ${duration}ms)`);
    
    return {
      success: true,
      filePath,
      size: stats.size,
      metadata: {
        fieldCount: 0, // Unknown for LibreOffice-generated PDFs
        tier,
        format,
        quality,
        generatedAt: new Date().toISOString(),
        method: 'libreoffice'
      }
    };
  }

  private setDocumentMetadata(
    pdfDoc: PDFDocument,
    format: Format,
    displayTier: string,
    quality: Quality,
    version: string
  ) {
    pdfDoc.setTitle(`Legacy Architecture Canvas - Interactive ${format} Edition`);
    pdfDoc.setAuthor("Abraham of London");
    pdfDoc.setSubject("Interactive Legacy Canvas Framework");
    pdfDoc.setKeywords(["legacy", "architecture", "canvas", "interactive", "framework", quality, displayTier]);
    pdfDoc.setProducer("Abraham of London Interactive PDF Engine v2.0");
    pdfDoc.setCreator(`Interactive PDF Generator v${version}`);
    pdfDoc.setCreationDate(new Date());
    pdfDoc.setModificationDate(new Date());
  }

  private drawDocument(
    pdfDoc: PDFDocument,
    page: PDFPage,
    options: {
      width: number;
      height: number;
      format: Format;
      tier: BuildTier;
      quality: Quality;
      displayTier: string;
      helvetica: any;
      helveticaBold: any;
      includeInstructions?: boolean;
      watermarked?: boolean;
      metadata?: Record<string, any>;
    }
  ) {
    const { 
      width, height, format, tier, quality, displayTier,
      helvetica, helveticaBold,
      includeInstructions, watermarked, metadata
    } = options;
    
    const tierColorRGB = tierColor(tier);
    
    // Watermark for premium tiers
    if (watermarked && (tier === 'architect' || tier === 'inner-circle')) {
      this.drawWatermark(page, width, height, displayTier, helveticaBold, tierColorRGB);
    }
    
    // Header section
    page.drawRectangle({
      x: 0,
      y: height - 100,
      width,
      height: 100,
      color: rgb(...tierColorRGB),
      opacity: 0.1
    });
    
    page.drawText("LEGACY ARCHITECTURE CANVAS", {
      x: 50,
      y: height - 60,
      size: 24,
      font: helveticaBold,
      color: rgb(0.1, 0.1, 0.3),
    });
    
    page.drawText("Interactive Premium Edition", {
      x: 50,
      y: height - 90,
      size: 14,
      font: helvetica,
      color: rgb(0.3, 0.3, 0.5),
    });
    
    // Info box
    page.drawText(`${format} Format ‚Ä¢ ${displayTier} Tier ‚Ä¢ ${quality.toUpperCase()} Quality`, {
      x: 50,
      y: height - 120,
      size: 10,
      font: helvetica,
      color: rgb(0.5, 0.5, 0.5),
    });
    
    if (metadata?.version) {
      page.drawText(`Version ${metadata.version}`, {
        x: width - 100,
        y: height - 120,
        size: 9,
        font: helvetica,
        color: rgb(0.5, 0.5, 0.5),
      });
    }
    
    // Footer instructions
    if (includeInstructions) {
      this.drawInstructions(page, width, height, helvetica);
    }
    
    // Copyright
    page.drawText(`¬© ${new Date().getFullYear()} Abraham of London`, {
      x: width - 150,
      y: 30,
      size: 8,
      font: helvetica,
      color: rgb(0.7, 0.7, 0.7),
    });
  }

  private drawWatermark(
    page: PDFPage,
    width: number,
    height: number,
    displayTier: string,
    font: any,
    tierColorRGB: [number, number, number]
  ) {
    // Tier watermark
    page.drawText(displayTier.toUpperCase(), {
      x: width / 2 - 100,
      y: height / 2,
      size: 48,
      font: font,
      color: rgb(...tierColorRGB),
      opacity: 0.03,
      rotate: { type: 'degrees', angle: 45 }
    });
    
    // Confidential stamp for inner-circle
    if (displayTier.toLowerCase().includes('inner')) {
      page.drawText("CONFIDENTIAL", {
        x: width - 180,
        y: 100,
        size: 18,
        font: font,
        color: rgb(0.9, 0.1, 0.1),
        opacity: 0.1,
        rotate: { type: 'degrees', angle: -30 }
      });
    }
  }

  private drawInstructions(page: PDFPage, width: number, height: number, font: any) {
    const instructions = [
      "This is an interactive PDF. Click any field and type to fill it out.",
      "Save your filled PDF to keep your legacy canvas updated.",
      "Use Adobe Acrobat Reader for best interactive experience.",
      "Fields are automatically saved when you save the document."
    ];
    
    let yPos = 80;
    instructions.forEach((instruction, index) => {
      page.drawText(`${index + 1}. ${instruction}`, {
        x: 50,
        y: yPos,
        size: 9,
        font: font,
        color: rgb(0.4, 0.4, 0.4),
      });
      yPos -= 16;
    });
  }

  private addInteractiveFields(
    form: any,
    page: PDFPage,
    options: {
      width: number;
      height: number;
      tier: BuildTier;
      helvetica: any;
    }
  ): number {
    const { width, height, tier, helvetica } = options;
    let fieldCount = 0;
    
    // Define canvas sections
    const sections = [
      { 
        title: "SOVEREIGN THESIS", 
        yTop: height - 190,
        fieldCount: 3
      },
      { 
        title: "CAPITAL MATRIX", 
        yTop: height - 340,
        fieldCount: 3
      },
      { 
        title: "INSTITUTIONS", 
        yTop: height - 490,
        fieldCount: 3
      },
      { 
        title: "GUARDRAILS", 
        yTop: height - 640,
        fieldCount: 3
      }
    ];
    
    const fieldWidth = width - 100;
    const fieldHeight = 26;
    
    // Draw sections and add fields
    sections.forEach((section, sectionIndex) => {
      // Draw section title
      page.drawText(section.title, {
        x: 50,
        y: section.yTop,
        size: 14,
        font: helvetica,
        color: rgb(0.2, 0.2, 0.4),
      });
      
      // Add fields for this section
      for (let i = 0; i < section.fieldCount; i++) {
        const y = section.yTop - 32 - (i * 40);
        
        // Draw field background
        page.drawRectangle({
          x: 50,
          y,
          width: fieldWidth,
          height: fieldHeight,
          borderColor: rgb(0.82, 0.82, 0.82),
          borderWidth: 1,
        });
        
        // Create interactive field
        const fieldName = `s${sectionIndex + 1}_field_${i + 1}`;
        const textField = form.createTextField(fieldName);
        
        textField.setText("");
        textField.addToPage(page, {
          x: 52,
          y: y + 2,
          width: fieldWidth - 4,
          height: fieldHeight - 4,
        });
        
        textField.setFontSize(10);
        
        fieldCount++;
      }
    });
    
    // Add footer instructions
    page.drawText("This is an interactive PDF. Click any field and type to fill it out.", {
      x: 50,
      y: 52,
      size: 10,
      font: helvetica,
      color: rgb(0.5, 0.5, 0.5),
    });
    
    page.drawText("Save your filled PDF to keep your legacy canvas updated.", {
      x: 50,
      y: 34,
      size: 10,
      font: helvetica,
      color: rgb(0.5, 0.5, 0.5),
    });
    
    return fieldCount;
  }

  // Static method for batch generation with fallback
  static async generateBatch(configs: InteractivePDFConfig[]): Promise<Array<{
    config: InteractivePDFConfig;
    result: GenerationResult;
  }>> {
    console.log(`üîÑ Starting batch generation of ${configs.length} interactive PDFs`);
    
    // Check LibreOffice availability once
    const loCheck = await LibreOfficeHelper.isAvailable();
    
    const results = [];
    for (const config of configs) {
      try {
        // If LibreOffice is requested but not available, fall back to pdf-lib
        const finalConfig = { ...config };
        if (config.useLibreOffice && !loCheck.available) {
          console.warn(`‚ö†Ô∏è LibreOffice not available for ${config.format} ${config.tier}, falling back to pdf-lib`);
          finalConfig.useLibreOffice = false;
        }
        
        const generator = new InteractivePDFGenerator(finalConfig);
        const result = await generator.generate();
        results.push({ config, result });
        
        // Small delay to prevent resource contention
        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (error) {
        console.error(`‚ùå Failed to generate PDF for ${config.format} ${config.tier}:`, error);
        results.push({
          config,
          result: {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          }
        });
      }
    }
    
    const successCount = results.filter(r => r.result.success).length;
    const methodBreakdown = {
      libreoffice: results.filter(r => r.result.metadata?.method === 'libreoffice').length,
      'pdf-lib': results.filter(r => r.result.metadata?.method === 'pdf-lib').length
    };
    
    console.log(`üìä Batch complete: ${successCount}/${configs.length} succeeded`);
    console.log(`üõ†Ô∏è  Methods: LibreOffice ${methodBreakdown.libreoffice}, pdf-lib ${methodBreakdown['pdf-lib']}`);
    
    return results;
  }
}

// Backward compatible function
async function generateInteractivePDF(
  format: Format, 
  quality: Quality, 
  tier: BuildTier, 
  outputDir: string,
  options?: {
    useLibreOffice?: boolean;
    libreOfficePath?: string;
  }
): Promise<GenerationResult> {
  const generator = new InteractivePDFGenerator({
    format,
    quality,
    tier,
    outputDir,
    useLibreOffice: options?.useLibreOffice,
    libreOfficePath: options?.libreOfficePath
  });
  
  return await generator.generate();
}

// Check LibreOffice availability helper
async function checkLibreOfficeInstallation(customPath?: string): Promise<{
  available: boolean;
  path?: string;
  version?: string;
  recommendedPath?: string;
}> {
  const check = await LibreOfficeHelper.isAvailable(customPath);
  
  if (!check.available) {
    // Suggest common installation paths
    const suggestions = [];
    
    if (process.platform === 'win32') {
      suggestions.push(
        'C:\\Program Files\\LibreOffice\\program\\soffice.exe',
        'C:\\Program Files (x86)\\LibreOffice\\program\\soffice.exe'
      );
    } else if (process.platform === 'darwin') {
      suggestions.push(
        '/Applications/LibreOffice.app/Contents/MacOS/soffice',
        '/usr/local/bin/libreoffice'
      );
    } else {
      suggestions.push(
        '/usr/bin/libreoffice',
        '/usr/local/bin/libreoffice',
        '/snap/bin/libreoffice'
      );
    }
    
    return {
      available: false,
      recommendedPath: suggestions.find(p => {
        try {
          fs.accessSync(p);
          return true;
        } catch {
          return false;
        }
      })
    };
  }
  
  return check;
}

// HELP FUNCTION - Show help message
function showHelp() {
  console.log(`
üöÄ Interactive PDF Generator
=============================

Usage:
  node scripts/pdf/generate-interactive-pdf.ts [options]
  npm run pdf:generate:interactive -- [options]

Options:
  --formats <list>          Comma-separated formats (A4,Letter,A3) [default: A4,Letter]
  --quality <value>         Quality level (standard,premium) [default: premium]
  --tier <value>            Tier (free,member,architect,inner-circle) [default: architect]
  --output-dir <path>       Output directory [default: ./public/assets/downloads]
  --version <value>         Version number [default: 1.0.0]
  
  --use-libreoffice         Use LibreOffice for generation (if available)
  --libreoffice-path <path> Custom LibreOffice executable path
  --no-instructions         Don't include instructions in PDF
  --no-watermark            Don't add watermark
  
  --check-libreoffice       Only check LibreOffice availability
  --help, -h                Show this help message

Examples:
  # Basic generation with pdf-lib
  node scripts/pdf/generate-interactive-pdf.ts --formats A4,Letter --quality premium
  
  # With LibreOffice (if installed)
  node scripts/pdf/generate-interactive-pdf.ts --use-libreoffice --formats A4
  
  # Check LibreOffice installation
  node scripts/pdf/generate-interactive-pdf.ts --check-libreoffice
  
  # Custom output directory
  node scripts/pdf/generate-interactive-pdf.ts --output-dir ./dist/downloads
  
  # Specific tier and quality
  node scripts/pdf/generate-interactive-pdf.ts --tier inner-circle --quality premium

Environment Variables:
  NODE_ENV=development      Enable verbose logging
  LIBREOFFICE_PATH=/path    Set default LibreOffice path
`);
}

// Main CLI function
async function main() {
  const args = process.argv.slice(2);
  
  // Handle --help flag
  if (args.includes('--help') || args.includes('-h')) {
    showHelp();
    return;
  }
  
  // Handle --check-libreoffice flag
  if (args.includes('--check-libreoffice')) {
    console.log('üîç Checking LibreOffice installation...');
    const check = await checkLibreOfficeInstallation();
    
    if (check.available) {
      console.log(`‚úÖ LibreOffice is available:`);
      console.log(`   Path: ${check.path}`);
      console.log(`   Version: ${check.version}`);
      console.log(`\nüí° Use with: --use-libreoffice`);
      if (check.path !== 'libreoffice' && check.path !== 'soffice') {
        console.log(`   Or specify path: --libreoffice-path "${check.path}"`);
      }
    } else {
      console.log(`‚ùå LibreOffice is not available.`);
      if (check.recommendedPath) {
        console.log(`üí° Try installing at: ${check.recommendedPath}`);
      }
      console.log(`\nüì¶ PDF generation will use built-in pdf-lib engine.`);
    }
    return;
  }
  
  const getArg = (key: string, defaultValue?: string) => {
    const i = args.indexOf(key);
    return i >= 0 && i + 1 < args.length ? args[i + 1] : defaultValue;
  };
  
  const hasFlag = (flag: string) => args.includes(flag);
  
  const formatsRaw = getArg("--formats", "A4,Letter");
  const quality = (getArg("--quality", "premium") || "premium") as Quality;
  const tier = (getArg("--tier", "architect") || "architect") as BuildTier;
  const outputDir = getArg("--output-dir", "./public/assets/downloads");
  const version = getArg("--version", "1.0.0");
  const libreOfficePath = getArg("--libreoffice-path");
  const useLibreOffice = hasFlag("--use-libreoffice");
  
  const formats: Format[] = formatsRaw
    .split(",")
    .map(normalizeFormat)
    .filter((v, i, a) => a.indexOf(v) === i);
  
  await fs.mkdir(outputDir, { recursive: true });
  
  console.log("üöÄ Generating Interactive PDFs...");
  
  // Check LibreOffice if requested
  if (useLibreOffice) {
    const loCheck = await checkLibreOfficeInstallation(libreOfficePath);
    if (!loCheck.available) {
      console.warn(`‚ö†Ô∏è LibreOffice not available at specified path`);
      if (loCheck.recommendedPath) {
        console.log(`üí° Try using: --libreoffice-path "${loCheck.recommendedPath}"`);
      }
      console.log(`üì¶ Falling back to built-in PDF generation`);
    } else {
      console.log(`‚úÖ Using LibreOffice ${loCheck.version}`);
    }
  }
  
  // Generate each format
  const results = [];
  for (const format of formats) {
    const config: InteractivePDFConfig = {
      format,
      quality,
      tier,
      outputDir,
      includeInstructions: !hasFlag("--no-instructions"),
      watermarked: !hasFlag("--no-watermark"),
      version,
      useLibreOffice: useLibreOffice,
      libreOfficePath: libreOfficePath
    };
    
    const generator = new InteractivePDFGenerator(config);
    const result = await generator.generate();
    results.push(result);
  }
  
  // Summary
  const successCount = results.filter(r => r.success).length;
  if (successCount === results.length) {
    console.log("\n‚úÖ All interactive PDFs generated successfully!");
  } else {
    console.log(`\n‚ö†Ô∏è  Generated ${successCount}/${results.length} PDFs successfully`);
    const errors = results.filter(r => !r.success).map(r => r.error);
    if (errors.length > 0) {
      console.log("Errors:", errors);
    }
  }
  
  // Show method breakdown
  const methodBreakdown = {
    libreoffice: results.filter(r => r.metadata?.method === 'libreoffice').length,
    'pdf-lib': results.filter(r => r.metadata?.method === 'pdf-lib').length
  };
  
  console.log(`\nüõ†Ô∏è  Generation methods:`);
  console.log(`   LibreOffice: ${methodBreakdown.libreoffice}`);
  console.log(`   PDF-lib: ${methodBreakdown['pdf-lib']}`);
}

// ESM-safe entry detection
const invokedAsScript = (() => {
  const argv1 = process.argv[1] ? path.resolve(process.argv[1]) : "";
  return argv1 === path.resolve(__filename);
})();

if (invokedAsScript) {
  main().catch((e) => {
    console.error(e);
    process.exit(1);
  });
}

// Export for use in other modules
export default InteractivePDFGenerator;
export { 
  generateInteractivePDF, 
  checkLibreOfficeInstallation,
  LibreOfficeHelper,
  type InteractivePDFConfig, 
  type GenerationResult,
  type LibreOfficeOptions
};

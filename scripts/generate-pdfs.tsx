// scripts/generate-pdfs.tsx - FIXED VERSION WITH CORRECT EXPORTS
import { getPDFRegistry, getAllPDFs, getPDFById } from './pdf-registry';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface GenerationResult {
  id: string;
  success: boolean;
  error?: string;
  duration: number;
  outputPath?: string;
}

class PDFGenerationPipeline {
  private results: GenerationResult[] = [];

  async generatePDF(id: string): Promise<GenerationResult> {
    const start = Date.now();
    
    try {
      console.log(`üöÄ Generating PDF: ${id}`);
      
      const pdf = getPDFById(id);
      if (!pdf) {
        throw new Error(`PDF with ID "${id}" not found`);
      }
      
      const outputPath = await this.createPDFFile(pdf);
      
      return {
        id,
        success: true,
        duration: Date.now() - start,
        outputPath
      };
    } catch (error: any) {
      return {
        id,
        success: false,
        error: error.message,
        duration: Date.now() - start
      };
    }
  }

  private async createPDFFile(pdfConfig: any): Promise<string> {
    const outputDir = path.join(process.cwd(), 'public', 'assets', 'downloads');
    
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    const outputPath = path.join(outputDir, `${pdfConfig.id}.pdf`);
    
    const pdfDoc = await PDFDocument.create();
    const timesRomanFont = await pdfDoc.embedFont(StandardFonts.TimesRoman);
    
    const page = pdfDoc.addPage([595, 842]);
    
    const { width, height } = page.getSize();
    const fontSize = 30;
    
    page.drawText(pdfConfig.title, {
      x: 50,
      y: height - 4 * fontSize,
      size: fontSize,
      font: timesRomanFont,
      color: rgb(0, 0, 0),
    });
    
    page.drawText(pdfConfig.description, {
      x: 50,
      y: height - 6 * fontSize,
      size: 14,
      font: timesRomanFont,
      color: rgb(0.5, 0.5, 0.5),
      maxWidth: width - 100,
    });
    
    page.drawText(`Generated by Abraham of London - ${new Date().toLocaleDateString()}`, {
      x: 50,
      y: 50,
      size: 10,
      font: timesRomanFont,
      color: rgb(0.3, 0.3, 0.3),
    });
    
    const pdfBytes = await pdfDoc.save();
    fs.writeFileSync(outputPath, pdfBytes);
    
    console.log(`‚úÖ Generated PDF: ${outputPath} (${pdfBytes.length} bytes)`);
    
    return `/assets/downloads/${pdfConfig.id}.pdf`;
  }

  async generateAll(): Promise<GenerationResult[]> {
    console.log('üöÄ Starting PDF Generation Pipeline...\n');
    
    const allPDFs = getAllPDFs();
    const missingPDFs = allPDFs.filter(pdf => !pdf.exists);
    
    console.log(`üìä Total PDFs in registry: ${allPDFs.length}`);
    console.log(`üìä Missing PDFs to generate: ${missingPDFs.length}\n`);
    
    if (missingPDFs.length === 0) {
      console.log('‚úÖ All PDFs are already generated.');
      return [];
    }
    
    for (const pdf of missingPDFs) {
      const result = await this.generatePDF(pdf.id);
      this.results.push(result);
      
      if (result.success) {
        console.log(`‚úÖ ${pdf.id}: Generated successfully`);
      } else {
        console.log(`‚ùå ${pdf.id}: ${result.error}`);
      }
    }
    
    this.report();
    return this.results;
  }

  async generateByType(type: string): Promise<GenerationResult[]> {
    console.log(`üöÄ Generating PDFs of type: ${type}\n`);
    
    const registry = getPDFRegistry();
    const pdfsToGenerate = Object.values(registry).filter(pdf => 
      pdf.type === type && !pdf.exists
    );
    
    if (pdfsToGenerate.length === 0) {
      console.log(`‚úÖ No PDFs of type "${type}" need generation.`);
      return [];
    }
    
    for (const pdf of pdfsToGenerate) {
      const result = await this.generatePDF(pdf.id);
      this.results.push(result);
      
      if (result.success) {
        console.log(`‚úÖ ${pdf.id}: Generated successfully`);
      } else {
        console.log(`‚ùå ${pdf.id}: ${result.error}`);
      }
    }
    
    this.report();
    return this.results;
  }

  private report(): void {
    const successful = this.results.filter(r => r.success).length;
    const failed = this.results.filter(r => !r.success).length;
    const totalDuration = this.results.reduce((acc, r) => acc + r.duration, 0);
    
    console.log('\n' + '='.repeat(50));
    console.log('üìä GENERATION REPORT');
    console.log('='.repeat(50));
    console.log(`‚úÖ Successful: ${successful}`);
    console.log(`‚ùå Failed: ${failed}`);
    console.log(`‚è±Ô∏è  Total duration: ${(totalDuration / 1000).toFixed(2)}s`);
    console.log('='.repeat(50));
    
    if (failed > 0) {
      console.log('\n‚ùå FAILED GENERATIONS:');
      this.results.filter(r => !r.success).forEach(r => {
        console.log(`  - ${r.id}: ${r.error}`);
      });
    }
  }
}

// CLI Runner class
class CommandRunner {
  static async runCommand(args: string[]): Promise<void> {
    const command = args[0];
    const pipeline = new PDFGenerationPipeline();
    
    switch (command) {
      case 'all':
        await pipeline.generateAll();
        break;
      case 'type':
        if (args.length < 2) {
          console.error('‚ùå Please specify a type: npm run generate-pdfs -- type <type>');
          process.exit(1);
        }
        await pipeline.generateByType(args[1]);
        break;
      case 'single':
        if (args.length < 2) {
          console.error('‚ùå Please specify a PDF ID: npm run generate-pdfs -- single <id>');
          process.exit(1);
        }
        await pipeline.generatePDF(args[1]);
        break;
      default:
        console.log('üìã Available commands:');
        console.log('  npm run generate-pdfs -- all');
        console.log('  npm run generate-pdfs -- type <type>');
        console.log('  npm run generate-pdfs -- single <id>');
        process.exit(0);
    }
  }
}

// Logger utility
class Logger {
  static info(message: string): void {
    console.log(`üìò INFO: ${message}`);
  }
  
  static warn(message: string): void {
    console.log(`‚ö†Ô∏è WARN: ${message}`);
  }
  
  static error(message: string): void {
    console.log(`‚ùå ERROR: ${message}`);
  }
  
  static success(message: string): void {
    console.log(`‚úÖ SUCCESS: ${message}`);
  }
}

// Orchestrator class that coordinates everything
class PDFGenerationOrchestrator {
  private pipeline: PDFGenerationPipeline;
  
  constructor() {
    this.pipeline = new PDFGenerationPipeline();
  }
  
  async orchestrate(args: string[] = []): Promise<void> {
    console.log('üéº PDF Generation Orchestrator');
    console.log('='.repeat(40));
    
    if (args.length > 0) {
      await CommandRunner.runCommand(args);
    } else {
      await this.pipeline.generateAll();
    }
    
    console.log('\nüéº Orchestration complete');
  }
}

// ‚úÖ FIXED: Export the actual classes that are defined in this file
export { PDFGenerationPipeline, PDFGenerationOrchestrator, CommandRunner, Logger };

// ‚úÖ Also export default for convenience
export default PDFGenerationOrchestrator;
/* scripts/pdf-registry.ts - GENERATED-SOURCE, PRODUCTION-OPTIMIZED, NEXT-SAFE */

// This is the single source of truth generated by scripts/pdf/intelligent-generator.ts
import {
  GENERATED_PDF_CONFIGS,
  type PDFConfigGenerated,
  type PDFTier as GeneratedTier,
  type PDFType as GeneratedType,
  type PDFFormat as GeneratedFormat,
} from "./pdf/pdf-registry.generated";

/* -------------------------------------------------------------------------- */
/* TYPES                                                                      */
/* -------------------------------------------------------------------------- */

export type PDFType =
  | "editorial" | "framework" | "academic" | "strategic" | "tool"
  | "canvas" | "worksheet" | "assessment" | "journal" | "tracker"
  | "bundle" | "other";

export type PDFFormat = "PDF" | "EXCEL" | "POWERPOINT" | "ZIP" | "BINARY";
export type PDFTier = "free" | "member" | "architect" | "inner-circle";
export type PaperFormat = "A4" | "Letter" | "A3" | "bundle";

export interface PDFConfig {
  id: string;
  title: string;
  description: string;
  excerpt?: string;
  outputPath: string;
  type: PDFType;
  format: PDFFormat;
  isInteractive: boolean;
  isFillable: boolean;
  category: string;
  tier: PDFTier;
  formats: PaperFormat[];
  fileSize: string; 
  lastModified: Date;
  exists: boolean;
  tags: string[];
  requiresAuth: boolean;
  version: string;
  priority?: number;
  preload?: boolean;
  placeholder?: string;
  md5?: string;
}

export interface PDFItem extends Omit<PDFConfig, "lastModified"> {
  lastModified: string; // ISO string for Next.js serialization
  fileUrl: string;
}

/* -------------------------------------------------------------------------- */
/* CONSTANTS & MAPPINGS                                                       */
/* -------------------------------------------------------------------------- */

export const PDF_TYPES: Record<PDFType, string> = {
  editorial: "Editorial",
  framework: "Framework",
  academic: "Academic",
  strategic: "Strategic",
  tool: "Tool",
  canvas: "Canvas",
  worksheet: "Worksheet",
  assessment: "Assessment",
  journal: "Journal",
  tracker: "Tracker",
  bundle: "Bundle",
  other: "Other",
};

export const PDF_TIERS: Record<PDFTier, string> = {
  free: "Free",
  member: "Member",
  architect: "Architect",
  "inner-circle": "Inner Circle",
};

export const CATEGORIES = {
  "surrender-framework": "Surrender Framework",
  legacy: "Legacy Architecture",
  theology: "Theology & Philosophy",
  leadership: "Leadership",
  "personal-growth": "Personal Growth",
  organizational: "Organizational",
} as const;

/* -------------------------------------------------------------------------- */
/* INTERNAL HELPERS                                                           */
/* -------------------------------------------------------------------------- */

function canonicalizeOutputPath(p: string): string {
  let v = (p || "").trim();
  if (!v.startsWith("/")) v = `/${v}`;
  v = v.replace(/^\/public\//, "/");
  v = v.replace(/^\/assets\/downloads\/downloads\//, "/assets/downloads/");
  return v;
}

function toRuntimeConfig(g: PDFConfigGenerated): PDFConfig {
  return {
    id: g.id,
    title: g.title,
    description: g.description,
    excerpt: g.excerpt,
    outputPath: canonicalizeOutputPath(g.outputPath),
    type: g.type as PDFType,
    format: g.format as PDFFormat,
    isInteractive: Boolean(g.isInteractive),
    isFillable: Boolean(g.isFillable),
    category: g.category || "downloads",
    tier: g.tier as PDFTier,
    formats: (g.formats || ["A4"]) as PaperFormat[],
    fileSize: g.fileSize || "0 KB",
    lastModified: new Date(g.lastModified),
    exists: Boolean(g.exists),
    tags: Array.isArray(g.tags) ? g.tags : [],
    requiresAuth: Boolean(g.requiresAuth),
    version: g.version || "1.0.0",
    priority: g.priority,
    preload: Boolean(g.preload),
    placeholder: g.placeholder,
    md5: g.md5,
  };
}

export function configToItem(config: PDFConfig): PDFItem {
  return {
    ...config,
    lastModified: config.lastModified.toISOString(),
    fileUrl: config.outputPath,
  };
}

/* -------------------------------------------------------------------------- */
/* REGISTRY INSTANTIATION (Memoized)                                          */
/* -------------------------------------------------------------------------- */

const PDF_REGISTRY_MAP: Map<string, PDFConfig> = new Map(
  (GENERATED_PDF_CONFIGS || []).map((g) => {
    const cfg = toRuntimeConfig(g);
    return [cfg.id, cfg] as const;
  })
);

// Cached collections for performance
let cachedAllPDFs: PDFConfig[] | null = null;
let cachedAllPDFItems: PDFItem[] | null = null;

/* -------------------------------------------------------------------------- */
/* PUBLIC API                                                                 */
/* -------------------------------------------------------------------------- */

export function getAllPDFs(): PDFConfig[] {
  if (!cachedAllPDFs) {
    cachedAllPDFs = Array.from(PDF_REGISTRY_MAP.values())
      .filter((pdf) => pdf.exists)
      .sort((a, b) => (a.priority || 999) - (b.priority || 999));
  }
  return cachedAllPDFs;
}

export function getAllPDFItems(): PDFItem[] {
  if (!cachedAllPDFItems) {
    cachedAllPDFItems = getAllPDFs().map(configToItem);
  }
  return cachedAllPDFItems;
}

export function getPDFById(id: string): PDFConfig | null {
  return PDF_REGISTRY_MAP.get(id) || null;
}

export function getPDFItemById(id: string): PDFItem | null {
  const cfg = getPDFById(id);
  return cfg ? configToItem(cfg) : null;
}

export function getPDFRegistry() {
  return Object.fromEntries(PDF_REGISTRY_MAP);
}

export function searchPDFs(query: string): PDFConfig[] {
  const q = (query || "").toLowerCase().trim();
  if (!q) return getAllPDFs();
  
  return getAllPDFs().filter((pdf) => 
    pdf.title.toLowerCase().includes(q) || 
    pdf.description.toLowerCase().includes(q) ||
    pdf.tags.some(t => t.toLowerCase().includes(q))
  );
}

const cachedByType: Map<PDFType, PDFConfig[]> = new Map();

export function getPDFsByType(type: PDFType): PDFConfig[] {
  if (!cachedByType.has(type)) {
    const filtered = getAllPDFs().filter(pdf => pdf.type === type);
    cachedByType.set(type, filtered);
  }
  return cachedByType.get(type)!;
}

// Stats for The Vault Dashboard
export function getPDFStats() {
  const all = Array.from(PDF_REGISTRY_MAP.values());
  return {
    total: all.length,
    available: all.filter(p => p.exists).length,
    interactive: all.filter(p => p.isInteractive).length,
    byTier: {
      free: all.filter(p => p.tier === 'free').length,
      member: all.filter(p => p.tier === 'member').length,
      architect: all.filter(p => p.tier === 'architect').length,
      "inner-circle": all.filter(p => p.tier === 'inner-circle').length,
    }
  };
}

export const STATIC_PDF_REGISTRY = Object.fromEntries(PDF_REGISTRY_MAP);
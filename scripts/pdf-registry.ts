/* scripts/pdf-registry.ts — GENERATED-SOURCE, PRODUCTION-OPTIMIZED, NEXT-SAFE
   Single source of truth generated by scripts/pdf/intelligent-generator.ts */

import fs from "node:fs";
import path from "node:path";

import {
  GENERATED_PDF_CONFIGS,
  type PDFConfigGenerated,
} from "./pdf/pdf-registry.generated";

/* -------------------------------------------------------------------------- */
/* TYPES                                                                      */
/* -------------------------------------------------------------------------- */

export type PDFType =
  | "editorial"
  | "framework"
  | "academic"
  | "strategic"
  | "tool"
  | "canvas"
  | "worksheet"
  | "assessment"
  | "journal"
  | "tracker"
  | "bundle"
  | "other";

export type PDFFormat = "PDF" | "EXCEL" | "POWERPOINT" | "ZIP" | "BINARY";
export type PDFTier = "free" | "member" | "architect" | "inner-circle";
export type PaperFormat = "A4" | "Letter" | "A3" | "bundle";

export interface PDFConfig {
  id: string;
  title: string;
  description: string;
  excerpt?: string;
  outputPath: string; // web path (e.g. /assets/downloads/foo.pdf)
  type: PDFType;
  format: PDFFormat;
  isInteractive: boolean;
  isFillable: boolean;
  category: string;
  tier: PDFTier;
  formats: PaperFormat[];
  fileSize: string;
  lastModified: Date;
  exists: boolean;
  tags: string[];
  requiresAuth: boolean;
  version: string;
  priority?: number;
  preload?: boolean;
  placeholder?: string;
  md5?: string;
}

export interface PDFItem extends Omit<PDFConfig, "lastModified"> {
  lastModified: string; // ISO for Next serialization
  fileUrl: string;
}

/* -------------------------------------------------------------------------- */
/* CONSTANTS                                                                  */
/* -------------------------------------------------------------------------- */

export const PDF_TYPES: Record<PDFType, string> = {
  editorial: "Editorial",
  framework: "Framework",
  academic: "Academic",
  strategic: "Strategic",
  tool: "Tool",
  canvas: "Canvas",
  worksheet: "Worksheet",
  assessment: "Assessment",
  journal: "Journal",
  tracker: "Tracker",
  bundle: "Bundle",
  other: "Other",
};

export const PDF_TIERS: Record<PDFTier, string> = {
  free: "Free",
  member: "Member",
  architect: "Architect",
  "inner-circle": "Inner Circle",
};

export const CATEGORIES = {
  "surrender-framework": "Surrender Framework",
  legacy: "Legacy Architecture",
  theology: "Theology & Philosophy",
  leadership: "Leadership",
  "personal-growth": "Personal Growth",
  organizational: "Organizational",
} as const;

/* -------------------------------------------------------------------------- */
/* PATH NORMALIZATION                                                         */
/* -------------------------------------------------------------------------- */

/**
 * Registry stores web paths. Normalize them into a canonical web path.
 * (Never touch filesystem here.)
 */
function canonicalizeOutputPath(p: string): string {
  let v = (p || "").trim();
  if (!v.startsWith("/")) v = `/${v}`;
  v = v.replace(/^\/public\//, "/");
  v = v.replace(/^\/assets\/downloads\/downloads\//, "/assets/downloads/");
  return v;
}

/**
 * Convert a web path (/assets/...) into an absolute filesystem path.
 * This is only used for safe stat checks — never scandir.
 */
function toFsPathFromWebPath(webPath: string): string {
  const clean = (webPath || "").trim().replace(/^\/+/, "");
  return path.join(process.cwd(), "public", clean);
}

function fileExistsSafeFromWebPath(webPath?: string): boolean {
  if (!webPath) return false;
  try {
    const abs = toFsPathFromWebPath(webPath);
    const st = fs.statSync(abs);
    return st.isFile();
  } catch {
    return false;
  }
}

/* -------------------------------------------------------------------------- */
/* TRANSFORMS                                                                 */
/* -------------------------------------------------------------------------- */

function toRuntimeConfig(g: PDFConfigGenerated): PDFConfig {
  const outputPath = canonicalizeOutputPath(g.outputPath);

  // Prefer generator truth; if it’s missing/false, we can optionally verify.
  // Keep this conservative to avoid Windows EPERM issues: only statSync a file.
  const exists =
    typeof g.exists === "boolean" ? g.exists : fileExistsSafeFromWebPath(outputPath);

  return {
    id: g.id,
    title: g.title,
    description: g.description,
    excerpt: g.excerpt,
    outputPath,
    type: g.type as PDFType,
    format: g.format as PDFFormat,
    isInteractive: Boolean(g.isInteractive),
    isFillable: Boolean(g.isFillable),
    category: g.category || "downloads",
    tier: g.tier as PDFTier,
    formats: (g.formats || ["A4"]) as PaperFormat[],
    fileSize: g.fileSize || "0 KB",
    lastModified: new Date(g.lastModified),
    exists,
    tags: Array.isArray(g.tags) ? g.tags : [],
    requiresAuth: Boolean(g.requiresAuth),
    version: g.version || "1.0.0",
    priority: g.priority,
    preload: Boolean(g.preload),
    placeholder: g.placeholder,
    md5: g.md5,
  };
}

export function configToItem(config: PDFConfig): PDFItem {
  return {
    ...config,
    lastModified: config.lastModified.toISOString(),
    fileUrl: config.outputPath,
  };
}

/* -------------------------------------------------------------------------- */
/* REGISTRY (SINGLE AUTHORITATIVE STORE)                                      */
/* -------------------------------------------------------------------------- */

const PDF_REGISTRY_MAP: Map<string, PDFConfig> = new Map(
  (GENERATED_PDF_CONFIGS || []).map((g) => {
    const cfg = toRuntimeConfig(g);
    return [cfg.id, cfg] as const;
  })
);

/**
 * Authoritative object form.
 * - Used for lightweight reads
 * - Stable for serialization
 */
export const STATIC_PDF_REGISTRY: Record<string, PDFConfig> = Object.fromEntries(PDF_REGISTRY_MAP);

/**
 * Back-compat alias: scripts/index.ts expects PDF_REGISTRY.
 */
export const PDF_REGISTRY = STATIC_PDF_REGISTRY;

/* -------------------------------------------------------------------------- */
/* CACHE INVALIDATION                                                         */
/* -------------------------------------------------------------------------- */

export function clearRegistryCache() {
  cachedAllPDFs = null;
  cachedAllPDFItems = null;
  cachedByType.clear();
  cachedByTier.clear();
}

/* -------------------------------------------------------------------------- */
/* PUBLIC API (UPDATED)                                                       */
/* -------------------------------------------------------------------------- */

export function getAllPDFs(opts?: { includeMissing?: boolean }): PDFConfig[] {
  // Re-verify existence if we aren't using the cache
  if (!cachedAllPDFs) {
    const includeMissing = Boolean(opts?.includeMissing);
    cachedAllPDFs = Array.from(PDF_REGISTRY_MAP.values())
      .map(cfg => ({
        ...cfg,
        // Re-check disk status to ensure 'exists' is accurate after a sync
        exists: fileExistsSafeFromWebPath(cfg.outputPath)
      }))
      .filter((pdf) => (includeMissing ? true : pdf.exists))
      .sort((a, b) => (a.priority ?? 999) - (b.priority ?? 999));
  }
  return cachedAllPDFs;

export function getPDFRegistry(): Record<string, PDFConfig> {
  return PDF_REGISTRY;
}

export function getAllPDFs(opts?: { includeMissing?: boolean }): PDFConfig[] {
  if (!cachedAllPDFs) {
    const includeMissing = Boolean(opts?.includeMissing);
    cachedAllPDFs = Array.from(PDF_REGISTRY_MAP.values())
      .filter((pdf) => (includeMissing ? true : pdf.exists))
      .sort((a, b) => (a.priority ?? 999) - (b.priority ?? 999));
  }
  return cachedAllPDFs;
}

export function getAllPDFItems(opts?: { includeMissing?: boolean }): PDFItem[] {
  if (!cachedAllPDFItems) {
    cachedAllPDFItems = getAllPDFs(opts).map(configToItem);
  }
  return cachedAllPDFItems;
}

export function getPDFById(id: string): PDFConfig | null {
  return PDF_REGISTRY_MAP.get(id) || null;
}

export function getPDFItemById(id: string): PDFItem | null {
  const cfg = getPDFById(id);
  return cfg ? configToItem(cfg) : null;
}

export function searchPDFs(query: string): PDFConfig[] {
  const q = (query || "").toLowerCase().trim();
  if (!q) return getAllPDFs();

  return getAllPDFs({ includeMissing: true }).filter(
    (pdf) =>
      pdf.title.toLowerCase().includes(q) ||
      pdf.description.toLowerCase().includes(q) ||
      (pdf.tags ?? []).some((t) => t.toLowerCase().includes(q))
  );
}

export function getPDFsByType(type: PDFType): PDFConfig[] {
  if (!cachedByType.has(type)) {
    cachedByType.set(type, getAllPDFs({ includeMissing: true }).filter((p) => p.type === type));
  }
  return cachedByType.get(type)!;
}

export function getPDFsByTier(tier: PDFTier): PDFConfig[] {
  if (!cachedByTier.has(tier)) {
    cachedByTier.set(tier, getAllPDFs({ includeMissing: true }).filter((p) => p.tier === tier));
  }
  return cachedByTier.get(tier)!;
}

export function getInteractivePDFs(): PDFConfig[] {
  return getAllPDFs({ includeMissing: true }).filter((p) => !!p.isInteractive);
}

export function getFillablePDFs(): PDFConfig[] {
  return getAllPDFs({ includeMissing: true }).filter((p) => !!p.isFillable);
}

export function getPDFStats() {
  const all = Array.from(PDF_REGISTRY_MAP.values());
  return {
    total: all.length,
    available: all.filter((p) => p.exists).length,
    interactive: all.filter((p) => p.isInteractive).length,
    fillable: all.filter((p) => p.isFillable).length,
    byTier: {
      free: all.filter((p) => p.tier === "free").length,
      member: all.filter((p) => p.tier === "member").length,
      architect: all.filter((p) => p.tier === "architect").length,
      "inner-circle": all.filter((p) => p.tier === "inner-circle").length,
    },
  };
}

/* -------------------------------------------------------------------------- */
/* BUILD-STABLE STUBS (EXPECTED BY scripts/index.ts)                           */
/* -------------------------------------------------------------------------- */

export function scanForDynamicAssets() {
  return {
    ok: true,
    found: [],
    message: "scanForDynamicAssets is a runtime-safe stub. Use CLI generator for scanning.",
  };
}

export function needsRegeneration(pdf: PDFConfig): boolean {
  // Conservative: missing output file -> needs regeneration.
  return !fileExistsSafeFromWebPath(pdf.outputPath);
}

export function getPDFsRequiringGeneration(): PDFConfig[] {
  return getAllPDFs({ includeMissing: true }).filter(needsRegeneration);
}

export async function generateMissingPDFs() {
  // Runtime-safe: do not generate inside Next build graph.
  const missing = getPDFsRequiringGeneration();
  return {
    ok: true,
    generated: 0,
    missing: missing.map((p) => p.id),
    message: "generateMissingPDFs is a runtime-safe no-op. Run the CLI generator in CI.",
  };
}
// scripts/pdf/build-pdf-registry-generated.ts
// Generates scripts/pdf/pdf-registry.generated.ts (Next-safe static exports)
//
// Guarantees:
// 1) outputPath is canonical: /assets/downloads/<file>.pdf
// 2) multi-format assets become separate entries (A4/Letter/A3) WITHOUT breaking base links
// 3) Always includes base entry (no format suffix) for backward compatibility
//
// IMPORTANT:
// - This script must NOT import scripts/pdf-registry.ts (runtime) because that imports generated outputs.
// - It reads ONLY from scripts/pdf/pdf-registry.source.ts

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

import { getPDFRegistrySource } from "./pdf-registry.source";

type Format = "A4" | "Letter" | "A3";
type Tier = "free" | "member" | "architect" | "inner-circle";

interface SourceItem {
  id: string;
  title: string;
  type: string;
  tier: Tier;

  outputPath: string;

  description?: string;
  excerpt?: string;
  tags?: string[];

  // The paper formats this doc supports (NOT file type)
  formats?: Array<"A4" | "Letter" | "A3" | "bundle">;

  // Optional metadata
  format?: "PDF" | "EXCEL" | "POWERPOINT" | "ZIP" | "BINARY";
  isInteractive?: boolean;
  isFillable?: boolean;
  requiresAuth?: boolean;
  version?: string;
  author?: string;
  category?: string;
  createdAt?: string;
  updatedAt?: string;
  fileSize?: string;
  pageCount?: number;

  priority?: number;
  preload?: boolean;
}

interface GeneratedPDFConfig {
  id: string;
  title: string;
  type: string;
  tier: Tier;
  outputPath: string;

  description?: string;
  excerpt?: string;
  tags?: string[];

  // metadata
  format?: Format; // paper format (A4/Letter/A3) for variants only
  isInteractive?: boolean;
  isFillable?: boolean;
  requiresAuth?: boolean;
  version?: string;
  author?: string;
  category?: string;
  createdAt?: string;
  updatedAt?: string;
  fileSize?: string;
  pageCount?: number;

  priority?: number;
  preload?: boolean;

  // always present for Next-safe registry parity if you want it later
  lastModified?: string;
  exists?: boolean;
}

const FORMATS: Format[] = ["A4", "Letter", "A3"];

function canonicalizeOutputPath(p: string | undefined, fallbackId: string): string {
  let pathStr = (p && String(p).trim()) || `/assets/downloads/${fallbackId}.pdf`;

  // normalize slashes
  pathStr = pathStr.replace(/\\/g, "/");

  // ensure leading slash
  if (!pathStr.startsWith("/")) pathStr = `/${pathStr}`;

  // collapse duplicate slashes
  pathStr = pathStr.replace(/\/{2,}/g, "/");

  // force /assets/downloads/
  if (!pathStr.startsWith("/assets/downloads/")) {
    const filename = path.posix.basename(pathStr);
    pathStr = `/assets/downloads/${filename}`;
  }

  // ensure extension
  if (!pathStr.toLowerCase().endsWith(".pdf")) {
    pathStr = `${pathStr}.pdf`;
  }

  return pathStr;
}

function addFormatSuffix(filePath: string, format: Format): string {
  const dir = path.posix.dirname(filePath);
  const base = path.posix.basename(filePath, ".pdf");
  return `${dir}/${base}-${format.toLowerCase()}.pdf`;
}

function formatVariantId(baseId: string, format: Format): string {
  return `${baseId}__${format.toLowerCase()}`;
}

function stableSort(a: GeneratedPDFConfig, b: GeneratedPDFConfig): number {
  const tierOrder: Record<Tier, number> = {
    "inner-circle": 0,
    architect: 1,
    member: 2,
    free: 3,
  };

  const ta = tierOrder[a.tier] ?? 99;
  const tb = tierOrder[b.tier] ?? 99;
  if (ta !== tb) return ta - tb;

  // base IDs before variants for the same title
  const aIsVariant = a.id.includes("__");
  const bIsVariant = b.id.includes("__");
  if (aIsVariant !== bIsVariant) return aIsVariant ? 1 : -1;

  return (a.title || a.id).localeCompare(b.title || b.id);
}

function ensureDir(dirPath: string): void {
  fs.mkdirSync(dirPath, { recursive: true });
}

function emitTypeScript(generatedConfigs: GeneratedPDFConfig[]): string {
  const now = new Date().toISOString();

  return `/**
 * AUTO-GENERATED FILE â€” DO NOT EDIT MANUALLY
 * Generated by: scripts/pdf/build-pdf-registry-generated.ts
 * Generated at: ${now}
 *
 * SAFE FOR NEXT.JS RUNTIME IMPORTS
 * - No fs
 * - No child_process
 * - Static exports only
 */

export type PDFTier = "free" | "member" | "architect" | "inner-circle";
export type PDFFormat = "A4" | "Letter" | "A3";
export type PDFType = string;

export interface PDFConfigGenerated {
  id: string;
  title: string;
  type: PDFType;
  tier: PDFTier;
  outputPath: string;

  description?: string;
  excerpt?: string;
  tags?: string[];

  /** Paper format for variant entries only */
  format?: PDFFormat;

  isInteractive?: boolean;
  isFillable?: boolean;
  requiresAuth?: boolean;
  version?: string;
  author?: string;
  category?: string;
  createdAt?: string;
  updatedAt?: string;
  fileSize?: string;
  pageCount?: number;
  priority?: number;
  preload?: boolean;

  /** Optional build-time metadata, if you later want to enrich */
  lastModified?: string;
  exists?: boolean;
}

export const GENERATED_PDF_CONFIGS: PDFConfigGenerated[] = ${JSON.stringify(generatedConfigs, null, 2)} as const;

export function getGeneratedPDFById(id: string): PDFConfigGenerated | null {
  return GENERATED_PDF_CONFIGS.find((x) => x.id === id) || null;
}

export function getGeneratedPDFs(): PDFConfigGenerated[] {
  return GENERATED_PDF_CONFIGS.slice();
}
`;
}

async function main(): Promise<void> {
  const source = getPDFRegistrySource() as SourceItem[];

  const generated: GeneratedPDFConfig[] = [];

  for (const item of source) {
    const baseId = item.id;
    const canonicalBasePath = canonicalizeOutputPath(item.outputPath, baseId);

    const baseEntry: GeneratedPDFConfig = {
      id: baseId,
      title: item.title,
      type: item.type,
      tier: item.tier,
      outputPath: canonicalBasePath,

      description: item.description,
      excerpt: item.excerpt,
      tags: item.tags,

      isInteractive: Boolean(item.isInteractive),
      isFillable: Boolean(item.isFillable),
      requiresAuth: Boolean(item.requiresAuth),

      version: item.version || "1.0.0",
      author: item.author,
      category: item.category,

      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
      fileSize: item.fileSize,
      pageCount: item.pageCount,

      priority: item.priority,
      preload: item.preload,
    };

    // ALWAYS include base entry
    generated.push(baseEntry);

    // Expand variants ONLY if formats includes at least one of A4/Letter/A3 and more than one, or explicitly contains them.
    const paperFormats = (item.formats || []).filter((f): f is Format =>
      f === "A4" || f === "Letter" || f === "A3",
    );

    const shouldExpand = paperFormats.length > 0 && paperFormats.length > 1;

    if (shouldExpand) {
      for (const fmt of FORMATS) {
        if (!paperFormats.includes(fmt)) continue;

        generated.push({
          ...baseEntry,
          id: formatVariantId(baseId, fmt),
          title: `${item.title} (${fmt})`,
          outputPath: addFormatSuffix(canonicalBasePath, fmt),
          format: fmt,
        });
      }
    }
  }

  generated.sort(stableSort);

  const outFile = path.join(process.cwd(), "scripts/pdf/pdf-registry.generated.ts");
  ensureDir(path.dirname(outFile));

  fs.writeFileSync(outFile, emitTypeScript(generated), "utf8");

  // Console summary (keep it simple; no emojis if you prefer)
  // eslint-disable-next-line no-console
  console.log(`Generated: ${path.relative(process.cwd(), outFile)}`);
  // eslint-disable-next-line no-console
  console.log(`Entries: ${generated.length} (base=${source.length}, variants=${generated.length - source.length})`);
}

// ESM-safe direct run guard for tsx
const __filename = fileURLToPath(import.meta.url);
const invokedAsScript = (() => {
  const argv1 = process.argv[1] ? path.resolve(process.argv[1]) : "";
  const here = path.resolve(__filename);
  return argv1 === here;
})();

if (invokedAsScript) {
  main().catch((err) => {
    // eslint-disable-next-line no-console
    console.error("Failed to build pdf-registry.generated.ts");
    // eslint-disable-next-line no-console
    console.error(err instanceof Error ? err.message : String(err));
    process.exit(1);
  });
}

export default main;
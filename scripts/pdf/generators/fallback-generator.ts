// scripts/pdf/generators/fallback-generator.ts
import fs from "fs";
import path from "path";

type FallbackOptions = {
  title: string;
  description: string;
  outPath: string; // absolute or relative path to PDF on disk
  tier: string;
  quality: string;
  keepHtml?: boolean; // default false
};

function ensureDirForFile(filePath: string) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function escapeHtml(input: string) {
  return (input ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function buildHtml(opts: FallbackOptions) {
  const title = escapeHtml(opts.title);
  const description = escapeHtml(opts.description);
  const tier = escapeHtml(opts.tier);
  const quality = escapeHtml(opts.quality);
  const now = new Date().toISOString();

  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>${title}</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; color: #111; }
    .header { border-bottom: 2px solid #333; padding-bottom: 16px; margin-bottom: 22px; }
    h1 { margin: 0; font-size: 26px; }
    .meta { color: #555; font-size: 12px; margin-top: 8px; }
    .badge { display: inline-block; padding: 2px 8px; border: 1px solid #999; border-radius: 999px; font-size: 11px; margin-right: 8px; }
    .content { margin-top: 18px; }
    .content p { margin: 10px 0; }
    .note { margin-top: 16px; padding: 12px 14px; border-left: 4px solid #b91c1c; background: #fff5f5; }
    .footer { margin-top: 36px; padding-top: 14px; border-top: 1px solid #ddd; font-size: 11px; color: #666; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <div class="header">
    <h1>${title}</h1>
    <div class="meta">
      <span class="badge">Tier: ${tier}</span>
      <span class="badge">Quality: ${quality}</span>
      <span class="badge">Generated: <span class="mono">${now}</span></span>
    </div>
  </div>

  <div class="content">
    <p>${description}</p>
    <div class="note">
      <p><strong>Placeholder PDF (Fallback)</strong></p>
      <p>This PDF was generated by the fallback generator because the primary generator was unavailable or failed.</p>
      <p>Next steps:</p>
      <ul>
        <li>Ensure the source file exists (e.g. <span class="mono">content/downloads/</span>).</li>
        <li>Ensure the correct generator is installed and reachable in your build environment.</li>
        <li>Re-run the PDF build pipeline.</li>
      </ul>
    </div>
  </div>

  <div class="footer">
    <p>Abraham of London — PDF Generation System</p>
    <p class="mono">This document was automatically generated.</p>
  </div>
</body>
</html>`;
}

async function tryPuppeteer(html: string, outPathAbs: string) {
  // ESM-safe dynamic import. If puppeteer isn't installed, this throws.
  const puppeteerModule: any = await import("puppeteer");
  const puppeteer = puppeteerModule?.default ?? puppeteerModule;

  const browser = await puppeteer.launch({
    headless: "new",
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  });

  try {
    const page = await browser.newPage();
    await page.setContent(html, { waitUntil: ["load", "domcontentloaded"] });

    await page.pdf({
      path: outPathAbs,
      printBackground: true,
      format: "A4",
      margin: { top: "18mm", right: "18mm", bottom: "18mm", left: "18mm" },
    });
  } finally {
    await browser.close();
  }
}

async function generatePdfLibFallback(opts: FallbackOptions, outPathAbs: string) {
  const pdfLib: any = await import("pdf-lib");
  const { PDFDocument, StandardFonts, rgb } = pdfLib;

  const doc = await PDFDocument.create();
  const page = doc.addPage([595.28, 841.89]); // A4 points

  const font = await doc.embedFont(StandardFonts.Helvetica);
  const fontBold = await doc.embedFont(StandardFonts.HelveticaBold);

  const marginX = 50;
  let y = 780;

  const title = opts.title || "Untitled";
  const description = opts.description || "";
  const meta = `Tier: ${opts.tier} | Quality: ${opts.quality} | Generated: ${new Date().toISOString()}`;

  page.drawText(title, { x: marginX, y, size: 22, font: fontBold, color: rgb(0.1, 0.1, 0.1) });
  y -= 28;

  page.drawText(meta, { x: marginX, y, size: 10, font, color: rgb(0.35, 0.35, 0.35) });
  y -= 26;

  // separator line
  page.drawLine({
    start: { x: marginX, y },
    end: { x: 595.28 - marginX, y },
    thickness: 1,
    color: rgb(0.75, 0.75, 0.75),
  });
  y -= 22;

  const wrapText = (text: string, maxChars = 85) => {
    const words = (text || "").split(/\s+/).filter(Boolean);
    const lines: string[] = [];
    let line = "";
    for (const w of words) {
      if ((line + " " + w).trim().length > maxChars) {
        if (line) lines.push(line);
        line = w;
      } else {
        line = (line ? line + " " : "") + w;
      }
    }
    if (line) lines.push(line);
    return lines;
  };

  const descLines = wrapText(description, 90);
  for (const ln of descLines.slice(0, 18)) {
    page.drawText(ln, { x: marginX, y, size: 12, font, color: rgb(0.15, 0.15, 0.15) });
    y -= 16;
    if (y < 140) break;
  }

  y -= 10;
  page.drawText("Placeholder PDF (Fallback)", {
    x: marginX,
    y,
    size: 12,
    font: fontBold,
    color: rgb(0.6, 0.1, 0.1),
  });
  y -= 18;

  const noteLines = wrapText(
    "This PDF was generated by the fallback generator because the primary generator was unavailable or failed. Ensure the proper generator is installed and the source exists, then re-run the PDF build.",
    95
  );

  for (const ln of noteLines.slice(0, 10)) {
    page.drawText(ln, { x: marginX, y, size: 10, font, color: rgb(0.3, 0.3, 0.3) });
    y -= 14;
    if (y < 90) break;
  }

  const bytes = await doc.save();
  fs.writeFileSync(outPathAbs, bytes);
}

export async function generateFallbackPDF(options: FallbackOptions) {
  const { outPath, keepHtml = false } = options;

  // Normalise to absolute path for writing
  const outPathAbs = path.isAbsolute(outPath) ? outPath : path.join(process.cwd(), outPath);

  ensureDirForFile(outPathAbs);

  const html = buildHtml(options);

  // Write temp HTML (useful for debugging + Puppeteer needs raw HTML anyway)
  const htmlPath = outPathAbs.replace(/\.pdf$/i, ".html");
  fs.writeFileSync(htmlPath, html, "utf-8");

  // Try Puppeteer first, then pdf-lib fallback.
  try {
    await tryPuppeteer(html, outPathAbs);
  } catch (err: any) {
    // Puppeteer not installed / chromium issues / sandbox restrictions — fall back to pdf-lib
    await generatePdfLibFallback(options, outPathAbs);
  } finally {
    if (!keepHtml) {
      try {
        if (fs.existsSync(htmlPath)) fs.unlinkSync(htmlPath);
      } catch {
        // ignore cleanup failures
      }
    }
  }

  // Hard guarantee: output exists and is non-empty
  if (!fs.existsSync(outPathAbs)) {
    throw new Error(`Fallback generator failed: output not created at ${outPathAbs}`);
  }
  const stats = fs.statSync(outPathAbs);
  if (stats.size < 500) {
    throw new Error(`Fallback generator produced an invalid PDF (${stats.size} bytes): ${outPathAbs}`);
  }

  return { outPath: outPathAbs, bytes: stats.size };
}
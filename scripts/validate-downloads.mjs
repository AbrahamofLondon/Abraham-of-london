// scripts/validate-downloads.mjs
import fs from "node:fs";
import path from "node:path";
import url from "node:url";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function main() {
  // Import contentlayer output (generated by `contentlayer2 build`)
  const generated = await import(
    path.join(process.cwd(), ".contentlayer", "generated", "index.mjs")
  );
  const { allDownloads } = generated;

  const publicRoot = path.join(process.cwd(), "public");
  const downloadsRoot = path.join(publicRoot, "downloads");

  const missingFiles = [];
  const unreferencedPdfs = [];

  // 1) For each Download, ensure its downloadHref exists if it points to /downloads
  for (const doc of allDownloads) {
    const href = doc.downloadHref || doc.downloadUrl || doc.fileUrl || "";

    if (!href) continue;

    // only enforce for local /downloads URLs
    if (!href.startsWith("/downloads/")) continue;

    const rel = href.replace(/^\/+/, ""); // strip leading slash
    const diskPath = path.join(publicRoot, rel);

    if (!fs.existsSync(diskPath)) {
      missingFiles.push({ slug: doc.slug, href, diskPath });
    }
  }

  // 2) For each .pdf in public/downloads, ensure it is referenced
  let pdfFiles = [];
  if (fs.existsSync(downloadsRoot)) {
    const walk = (dir) => {
      for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
        const full = path.join(dir, entry.name);
        if (entry.isDirectory()) walk(full);
        else if (entry.isFile() && full.toLowerCase().endsWith(".pdf")) {
          pdfFiles.push(full);
        }
      }
    };
    walk(downloadsRoot);
  }

  const usedPaths = new Set(
    allDownloads
      .map((doc) => doc.downloadHref || doc.downloadUrl || doc.fileUrl || "")
      .filter((href) => href.startsWith("/downloads/"))
      .map((href) =>
        path.join(publicRoot, href.replace(/^\/+/, "")),
      ),
  );

  for (const pdfPath of pdfFiles) {
    if (!usedPaths.has(pdfPath)) {
      unreferencedPdfs.push(pdfPath);
    }
  }

  // 3) Report and exit with non-zero if problems
  if (missingFiles.length || unreferencedPdfs.length) {
    console.error("❌ Download validation failed.");

    if (missingFiles.length) {
      console.error("\nMissing files (referenced in MDX but not found on disk):");
      for (const m of missingFiles) {
        console.error(
          ` - slug=${m.slug} href=${m.href} -> expected at ${m.diskPath}`,
        );
      }
    }

    if (unreferencedPdfs.length) {
      console.error("\nUnreferenced PDFs in public/downloads:");
      for (const p of unreferencedPdfs) {
        console.error(` - ${p}`);
      }
    }

    process.exit(1);
  } else {
    console.log("✅ Downloads validation passed: all links and files are consistent.");
  }
}

main().catch((err) => {
  console.error("Error while validating downloads:", err);
  process.exit(1);
});